<!DOCTYPE html>
<html lang="en">

<head>
    <title>
        Java Documentation - Protik The DEV
    </title>

    <!-- Meta -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Java Documentation For Software Developers" />
    <meta name="author" content="Protik The DEV" />
    <link rel="shortcut icon" href="favicon.png" />

    <!-- Google Font -->
    <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet" />

    <!-- FontAwesome JS-->
    <script defer src="assets/fontawesome/js/all.min.js"></script>

    <!-- Plugins CSS -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.2/styles/atom-one-dark.min.css" />
    <link rel="stylesheet" href="assets/plugins/simplelightbox/simple-lightbox.min.css" />

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/theme.css" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-TCN8REREGW"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-TCN8REREGW');
    </script>
</head>

<body>

    <header class="header fixed-top">
        <div class="branding docs-branding">
            <div class="container-fluid position-relative py-2">
                <div class="docs-logo-wrapper">
                    <button id="docs-sidebar-toggler" class="docs-sidebar-toggler docs-sidebar-visible me-2 d-xl-none"
                        type="button">
                        <span></span>
                        <span></span>
                        <span></span>
                    </button>
                    <div class="site-logo">
                        <a class="navbar-brand" href="index.html"><img class="logo-icon me-2" src="favicon.png"
                                alt="logo" width="50px" /><span class="logo-text">Java <span
                                    class="text-alt">Documentation</span></span></a>
                    </div>
                </div>
                <!--//docs-logo-wrapper-->
                <div class="docs-top-utilities d-flex justify-content-end align-items-center">
                    <!-- Include Lunr.js -->
                    <script src="https://unpkg.com/lunr/lunr.js"></script>
                    <!-- Your search form -->
                    <div class="top-search-box d-none d-lg-flex">
                        <form class="search-form" id="searchForm">
                            <input type="text" placeholder="Search the docs..." name="search"
                                class="form-control search-input" id="searchInput" />
                            <button type="submit" class="btn search-btn" value="Search">
                                <i class="fas fa-search"></i>
                            </button>
                        </form>
                    </div>

                    <ul class="social-list list-inline mx-md-3 mx-lg-5 mb-0 d-none d-lg-flex">
                        <li class="list-inline-item">
                            <a href="https://github.com/protik-das-utso" target="_blank"><i
                                    class="fa-brands fa-github fa-fw"></i></a>
                        </li>
                        <li class="list-inline-item">
                            <a href="https://t.me/protikthedev" target="_blank"><i
                                    class="fa-brands fa-telegram fa-fw"></i></a>
                        </li>
                        <li class="list-inline-item">
                            <a href="http://facebook.com/protikthedeveloper" target="_blank"><i
                                    class="fa-brands fa-facebook fa-fw"></i></a>
                        </li>
                        <li class="list-inline-item">
                            <a href="https://www.youtube.com/@protikthedev" target="_blank"><i
                                    class="fa-brands fa-youtube fa-fw"></i></a>
                        </li>
                    </ul>
                    <!--//social-list-->
                    <a href="https://t.me/protikthedev" target="_blank" class="btn btn-primary d-none d-lg-flex">Join
                        Telegram</a>
                </div>
                <!--//docs-top-utilities-->
            </div>
            <!--//container-->
        </div>
        <!--//branding-->
    </header>
    <!--//header-->

    <div class="docs-wrapper">

        <div id="docs-sidebar" class="docs-sidebar">
            <div class="top-search-box d-lg-none p-3">
                <form class="search-form">
                    <input type="text" placeholder="Search the docs..." name="search"
                        class="form-control search-input" />
                    <button type="submit" class="btn search-btn" value="Search">
                        <i class="fas fa-search"></i>
                    </button>
                </form>
            </div>
            <nav id="docs-nav" class="docs-nav navbar">
                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title">
                        <a class="nav-link scrollto active" href="#week-1"><span class="theme-icon-holder me-2"><i
                                    class="fas fa-map-signs"></i></span>Week 1</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#week-1">Course Introduction</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-1" b style="color: red;">Class 1 - Recording</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-2">JDK & IDE Setup</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-3">Java Structure</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-4">Data Types</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-5">Variables</a>
                    </li>
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="#section-2"><span class="theme-icon-holder me-2"><i
                                    class="fas fa-arrow-down"></i></span>Week 2</a>
                    </li>
                    <!-- <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-1">Section Item 2.1</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-2">Section Item 2.2</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-3">Section Item 2.3</a>
                    </li> -->
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="#section-3"><span class="theme-icon-holder me-2"><i
                                    class="fas fa-box"></i></span>Week 3</a>
                    </li>
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="#section-4"><span class="theme-icon-holder me-2"><i
                                    class="fas fa-cogs"></i></span>Week 4</a>
                    </li>
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="#section-5"><span class="theme-icon-holder me-2"><i
                                    class="fas fa-tools"></i></span>Week 5</a>
                    </li>
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="#section-6"><span class="theme-icon-holder me-2"><i
                                    class="fas fa-laptop-code"></i></span>Week 6</a>
                    </li>
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="#section-7"><span class="theme-icon-holder me-2"><i
                                    class="fas fa-tablet-alt"></i></span>Week 7</a>
                    </li>
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="#section-8"><span class="theme-icon-holder me-2"><i
                                    class="fas fa-book-reader"></i></span>Week 8</a>
                    </li>
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link scrollto" href="#section-9"><span class="theme-icon-holder me-2"><i
                                    class="fas fa-lightbulb"></i></span>Week 9</a>
                    </li>
                </ul>
            </nav>
            <!--//docs-nav-->
        </div>


        <!--//docs-sidebar-->
        <div class="docs-content">
            <div class="container">
                <article class="docs-article" id="week-1">
                    <header class="docs-header">
                        <h1 class="docs-heading">
                            Course Introduction
                        </h1>
                        <!-- Search Results -->
                        <div id="searchResults"></div>
                        <script>
                            document.addEventListener('DOMContentLoaded', function () {
                                if (typeof lunr === 'undefined') {
                                    console.error('Lunr.js not found. Load https://unpkg.com/lunr/lunr.js before this script.');
                                    return;
                                }

                                // ----------------------------
                                // 1) Utilities
                                // ----------------------------
                                const scope = document.querySelector('.docs-content') || document;
                                const isHeading = n => n && /^H[1-6]$/.test(n.tagName);
                                const levelBoost = { H1: 12, H2: 8, H3: 5, H4: 3, H5: 2 };

                                // Normalize for case/diacritics to keep searching standard & user-friendly
                                const normalize = s =>
                                    (s || '')
                                        .normalize('NFKD')
                                        .replace(/[\u0300-\u036f]/g, '')   // strip accents
                                        .replace(/\s+/g, ' ')
                                        .trim();

                                function snippetFrom(el, limit = 260) {
                                    let txt = '';
                                    let n = el.nextElementSibling;
                                    while (n && !isHeading(n)) {
                                        if (n.matches('p, ul, ol, pre, code, table, blockquote')) {
                                            txt += ' ' + normalize(n.innerText);
                                            if (txt.length >= limit) break;
                                        }
                                        n = n.nextElementSibling;
                                    }
                                    return txt.trim().slice(0, limit);
                                }

                                // ----------------------------
                                // 2) Collect documents (H1..H5) with clean breadcrumbs
                                // ----------------------------
                                const docs = [];
                                let h1 = '', h2 = '', h3 = '';
                                const nodes = scope.querySelectorAll('h1.docs-heading, h2, h3');

                                nodes.forEach((el, i) => {
                                    if (el.closest('#docs-sidebar')) return;              // ignore sidebar
                                    const tag = el.tagName;                               // "H1".."H5"
                                    const level = parseInt(tag[1], 10);                   // 1..5

                                    if (tag === 'H1') { h1 = normalize(el.textContent); h2 = h3 = ''; }
                                    if (tag === 'H2') { h2 = normalize(el.textContent); h3 = ''; }
                                    if (tag === 'H3') { h3 = normalize(el.textContent); }

                                    if (!el.id) el.id = 'heading-' + i;

                                    const title = normalize(el.textContent);
                                    // Breadcrumb without duplicates; H1 shows only itself
                                    let ancestors = [h1, h2, h3].filter(Boolean).filter(a => a !== title);
                                    const breadcrumb = (level === 1) ? title : [...ancestors, title].join(' ‚Ä∫ ');

                                    docs.push({
                                        id: el.id,
                                        level,
                                        title,
                                        breadcrumb,
                                        content: snippetFrom(el),
                                        url: '#' + el.id,
                                        boost: levelBoost[tag] || 1
                                    });
                                });

                                // ----------------------------
                                // 3) Build index (title > breadcrumb > content)
                                // ----------------------------
                                const idx = lunr(function () {
                                    this.ref('id');
                                    this.field('title', { boost: 9 });
                                    this.field('breadcrumb', { boost: 6 });
                                    this.field('content', { boost: 1 });

                                    // Pipeline already lowercases / stems; we pre-normalize too
                                    docs.forEach(d => {
                                        this.add({
                                            id: d.id,
                                            title: d.title,
                                            breadcrumb: d.breadcrumb,
                                            content: d.content
                                        }, { boost: d.boost });
                                    });
                                });

                                // ----------------------------
                                // 4) Query parsing (phrase, boolean, prefix, fuzzy)
                                // ----------------------------
                                // Supports:
                                //   - Phrases in quotes: "bytecode verifier"
                                //   - Words: java, structure
                                //   - Prefix with *: jav*
                                //   - Simple OR with ' OR ' (default is AND across terms)
                                function parseQuery(qRaw) {
                                    const q = normalize(qRaw).toLowerCase();
                                    if (!q) return { groups: [] };

                                    // Split by OR (optional). Each group is ANDed internally; groups are ORed
                                    const groups = q.split(/\s+or\s+/i).map(g => g.trim()).filter(Boolean);

                                    return {
                                        groups: groups.map(group => {
                                            // Extract phrases in quotes
                                            const phrases = [];
                                            let rest = group.replace(/"([^"]+)"/g, (_, p1) => { phrases.push(p1.trim()); return ' '; }).trim();

                                            // Remaining terms (keep * for explicit prefix)
                                            const terms = rest.split(/\s+/).filter(Boolean);

                                            return { phrases, terms };
                                        })
                                    };
                                }

                                function buildQuery(qRaw) {
                                    const parsed = parseQuery(qRaw);

                                    return function (query) {
                                        if (!parsed.groups.length) return;

                                        // For each OR group
                                        parsed.groups.forEach((g, gi) => {
                                            // Phrases: require one of title/breadcrumb/content (pipeline + high boost)
                                            g.phrases.forEach(ph => {
                                                // Exact phrase in title/breadcrumb gets top boost
                                                query.clause({
                                                    term: ph,
                                                    fields: ['title', 'breadcrumb'],
                                                    presence: lunr.Query.presence.REQUIRED,
                                                    usePipeline: true,
                                                    boost: 10
                                                });
                                                // Also allow in content (optional, lower boost)
                                                query.clause({
                                                    term: ph,
                                                    fields: ['content'],
                                                    presence: lunr.Query.presence.OPTIONAL,
                                                    usePipeline: true,
                                                    boost: 3
                                                });
                                            });

                                            // Terms: AND across the group, with prefix/fuzzy + pipeline
                                            g.terms.forEach(t => {
                                                const isPrefix = /\*$/.test(t);
                                                const term = isPrefix ? t.replace(/\*+$/, '') : t;
                                                const isLong = term.length >= 5;

                                                // One clause across multiple fields = OR between fields, REQUIRED overall
                                                query.clause({
                                                    term: term,
                                                    fields: ['title', 'breadcrumb', 'content'],
                                                    presence: lunr.Query.presence.REQUIRED,
                                                    usePipeline: true,
                                                    wildcard: isPrefix ? lunr.Query.wildcard.TRAILING : lunr.Query.wildcard.NONE,
                                                    editDistance: isLong ? 2 : 1,   // tolerate minor typos
                                                    boost: 5
                                                });
                                            });
                                        });
                                    };
                                }

                                // ----------------------------
                                // 5) Rendering (H1 first, then others; highlight; small UX polish)
                                // ----------------------------
                                const desktopForm = document.getElementById('searchForm');
                                const desktopInput = document.getElementById('searchInput');
                                const mobileInput = document.querySelector('#docs-sidebar .search-input');
                                const inputs = [desktopInput, mobileInput].filter(Boolean);

                                let resultBox = document.getElementById('searchResults');
                                if (!resultBox) {
                                    resultBox = document.createElement('div');
                                    resultBox.id = 'searchResults';
                                    const heading = scope.querySelector('.docs-heading');
                                    (heading ? heading.parentElement : document.body).appendChild(resultBox);
                                }

                                function esc(s) { return s.replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c])); }
                                function hi(text, terms) {
                                    if (!text) return '';
                                    const pattern = terms.length ? terms.map(t => t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|') : null;
                                    return pattern ? esc(text).replace(new RegExp(`\\b(${pattern})`, 'gi'), '<mark>$1</mark>') : esc(text);
                                }
                                function makeSnippet(content, terms, len = 200) {
                                    if (!content) return '';
                                    const lower = content.toLowerCase();
                                    let idx = 0;
                                    for (const t of terms) {
                                        const i = lower.indexOf(t);
                                        if (i !== -1) { idx = i; break; }
                                    }
                                    const start = Math.max(0, idx - 40);
                                    const slice = content.slice(start, start + len);
                                    return (start > 0 ? '‚Ä¶ ' : '') + slice + (start + len < content.length ? ' ‚Ä¶' : '');
                                }

                                function render(results, qRaw) {
                                    const q = normalize(qRaw).toLowerCase();
                                    const terms = q.replace(/"([^"]+)"/g, '$1').split(/\s+|or/ig).map(s => s.trim()).filter(Boolean);

                                    if (!results.length) { resultBox.innerHTML = '<p>No results found.</p>'; return; }

                                    // Map to docs, unique, then split H1 vs others
                                    const seen = new Set();
                                    const mapped = results.map(r => docs.find(d => d.id === r.ref)).filter(Boolean)
                                        .filter(d => (seen.has(d.id) ? false : seen.add(d.id)));

                                    const h1s = mapped.filter(d => d.level === 1);
                                    const rest = mapped.filter(d => d.level !== 1);

                                    // If any H1 match, show H1 group first, then others
                                    const groups = h1s.length ? [{ title: 'Top-level sections', items: h1s },
                                    { title: 'More results', items: rest }] :
                                        [{ title: 'Results', items: rest }];

                                    const html = groups.map(g => {
                                        if (!g.items.length) return '';
                                        const itemsHtml = g.items.map(d => {
                                            const snip = makeSnippet(d.content || d.title, terms);
                                            return `
          <li style="margin:0 0 10px;">
            <a href="${d.url}" class="fw-bold">${hi(d.breadcrumb, terms)}</a><br>
            <small style="color:#666;">${hi(snip, terms)}</small>
          </li>`;
                                        }).join('');
                                        return `
        <div style="margin:8px 0 12px;">
          <div style="font-weight:700;margin-bottom:6px;">${esc(g.title)}</div>
          <ul style="list-style:none;padding-left:0;margin:0;">
            ${itemsHtml}
          </ul>
        </div>`;
                                    }).join('');

                                    resultBox.innerHTML = html;
                                }

                                function runSearch(qRaw) {
                                    if (!qRaw || !qRaw.trim()) { resultBox.innerHTML = ''; return; }
                                    try {
                                        const res = idx.query(buildQuery(qRaw)).sort((a, b) => b.score - a.score);
                                        render(res, qRaw);
                                    } catch (e) {
                                        // Simple substring fallback (still normalized)
                                        const q = normalize(qRaw).toLowerCase();
                                        const res = docs
                                            .filter(d => (d.title + ' ' + d.breadcrumb + ' ' + d.content).toLowerCase().includes(q))
                                            .map(d => ({ ref: d.id, score: 0.0001 }));
                                        render(res, qRaw);
                                    }
                                }

                                // Submit + live search (debounced)
                                const desktopFormEl = document.getElementById('searchForm');
                                if (desktopFormEl) {
                                    desktopFormEl.addEventListener('submit', e => {
                                        e.preventDefault();
                                        runSearch((desktopInput?.value || '').trim());
                                    });
                                }
                                let deb;
                                inputs.forEach(inp => inp && inp.addEventListener('input', () => {
                                    clearTimeout(deb);
                                    deb = setTimeout(() => runSearch(inp.value), 150);
                                }));

                                console.log('Indexed sections:', docs.length);
                            });
                        </script>


                        <section class="docs-intro">
                            <p>
                                Welcome to the Basic Java to Advanced Spring Boot Backend
                                Development Course ‚Äî a six-month journey designed to take you
                                from the fundamentals of Java programming to building
                                full-stack backend applications.
                            </p>

                            <p>
                                This course begins with Core Java Essentials, covering syntax,
                                OOP, and debugging skills, and later expands into JDBC, Spring
                                Boot, REST APIs, Security, and Microservices
                            </p>
                        </section>
                        <!--//docs-intro-->

                        <h3>Mentor:</h3>
                        <p>
                            <a class="theme-link" href="https://facebook.com/protikthedev" target="_blank">PROTIK DAS
                                UTSO</a>
                        </p>
                        <i>Dept. of CSE, Daffodil International University</i>
                        <div class="alert alert-success" role="alert">
                            ‚ÄúI don‚Äôt just write code ‚Äî I build possibilities.‚Äù
                        </div>

                        <h2>Learning Goals:</h2>
                        <ul>
                            <li>Understand the core concepts of Java programming.</li>
                            <li>
                                Set up the development environment for efficient coding.
                            </li>
                            <li>Learn how to structure, compile, and run Java programs.</li>
                            <li>
                                Build a strong foundation for advanced backend technologies
                                such as Spring Boot.
                            </li>
                        </ul>
                        <h2>Course Structure</h2>
                        <ul>
                            <li><strong>Duration</strong> ‚Äî 24 weeks | 6 months</li>
                            <li>
                                <strong>Schedule</strong> ‚Äî 3 classes per week √ó 1.5 hours
                                each
                            </li>
                            <li>
                                <strong>Total</strong> ‚Äî ‚âà 108 hours + 12 hours
                                problem-solving sessions
                            </li>
                        </ul>
                        <h2>Outcome:</h2>
                        <p>
                            After this introduction, you‚Äôll clearly understand what Java is,
                            why it‚Äôs relevant, and how this course will progressively build
                            your development skills.
                        </p>

                        <div class="alert alert-secondary" role="alert"
                            style="display: flex; justify-content: space-between; align-items: center;">
                            <p style="align-items: center; margin-top: 15px;">üìö Course Outline</p>
                            <button class="btn btn-outline-secondary btn-sm"><a href="https://t.me/protikthedev/10"
                                    target="_blank" style="font-size: 20px;">Download</a></button>
                        </div>
                    </header>
                    <!-- JDK & IDE Setup -->
                    <section class="docs-section" id="item-1-1">
                        <h1 class="docs-heading">
                            Class 1 - Recording
                        </h1>

                        <iframe width="560" height="315"
                            src="https://www.youtube.com/embed/hPF2XUoWNn8?si=Coq6YMQzeuGbEDlK"
                            title="YouTube video player" frameborder="0"
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                            referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

                    </section>
                    <!--//section-->

                    <!-- JDK & IDE Setup -->
                    <section class="docs-section" id="item-1-2">
                        <h1 class="docs-heading">
                            JDK & IDE Setup
                        </h1>
                        <h2>‚òï 1. JDK (Java Development Kit)</h2>
                        <p>Used to write and compile Java programs.</p>
                        <p><strong>Contains:</strong> JRE + compiler (<code>javac</code>) + tools.</p>
                        <p><strong>üí° Example:</strong> When you type:</p>
                        <pre><code>javac Hello.java</code></pre>
                        <p>you‚Äôre using the JDK to compile your code.</p>

                        <h2>‚öôÔ∏è 2. JRE (Java Runtime Environment)</h2>
                        <p>Used to run Java programs.</p>
                        <p><strong>Contains:</strong> JVM + libraries needed to execute code.</p>
                        <p><strong>üí° Example:</strong> When you run:</p>
                        <pre><code>java Hello</code></pre>
                        <p>the JRE runs your compiled program.</p>

                        <h2>üíª 3. JVM (Java Virtual Machine)</h2>
                        <p>The engine that executes the compiled Java bytecode.</p>
                        <p>It makes Java platform-independent ‚Äî the same code can run on Windows, Mac, or Linux.</p>
                        <p><strong>üí° Example:</strong> The <code>.class</code> file created by the JDK is executed by
                            the JVM inside the JRE.</p>

                        <h2>üß© In short</h2>
                        <ul>
                            <li><strong>JDK</strong> = JRE + Development Tools</li>
                            <li><strong>JRE</strong> = JVM + Libraries</li>
                        </ul>

                        <h2>üîÅ Example flow</h2>
                        <ol>
                            <li>You write a program ‚Üí <code>Hello.java</code></li>
                            <li>JDK compiles it ‚Üí creates <code>Hello.class</code> (bytecode)</li>
                            <li>JRE runs it ‚Üí JVM executes bytecode line by line</li>
                        </ol>

                        <h2>Step-by-Step Installation</h2>
                        <ol>
                            <li>Download the latest JDK from <a
                                    href="https://www.oracle.com/apac/java/technologies/downloads/"
                                    target="_blank">Oracle</a> or <a href="https://openjdk.org/"
                                    target="_blank">OpenJDK</a>.</li>
                            <li>Install and follow the wizard for your OS.</li>
                        </ol>

                        <h2>Set Environment Variables</h2>
                        <p><strong>Windows:</strong> Add <code>JAVA_HOME</code> to System Variables ‚Üí point to JDK
                            folder.</p>
                        <p><strong>Mac/Linux:</strong> Add to <code>.bashrc</code> or <code>.zshrc</code>:</p>
                        <pre><code>export JAVA_HOME=/usr/lib/jvm/java-17-openjdk
export PATH=$JAVA_HOME/bin:$PATH</code></pre>

                        <h2>Verify Installation</h2>
                        <pre><code>java -version
javac -version</code></pre>
                        <p>Output should display the installed version.</p>

                        <h2>Installing an IDE</h2>
                        <p>An IDE (Integrated Development Environment) helps you code faster and debug easier.</p>
                        <ul>
                            <li><strong>IntelliJ IDEA:</strong> Smart and modern, ideal for professionals.</li>
                            <li><strong>Eclipse:</strong> Stable and used widely in enterprises.</li>
                            <li><strong>VS Code:</strong> Lightweight with Java extensions.</li>
                        </ul>

                        <h2>IDE Setup Checklist</h2>
                        <ol>
                            <li>Open the IDE ‚Üí Select <strong>New Project</strong> ‚Üí <strong>Java Project</strong>.</li>
                            <li>Set the project SDK to your installed JDK.</li>
                            <li>Create a class file and write:</li>
                        </ol>

                        <pre><code>public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, Java!");
    }
}</code></pre>

                        <p>Click <strong>Run</strong> ‚Äî your first Java program is live!</p>

                        <h2>Troubleshooting Tips</h2>
                        <ul>
                            <li><strong>‚Äújavac not found‚Äù</strong> ‚Üí Check PATH variable.</li>
                            <li><strong>‚ÄúCannot find symbol‚Äù</strong> ‚Üí Ensure file and class names match.</li>
                            <li><strong>IDE red underlines</strong> ‚Üí Set the correct JDK path in project settings.</li>
                        </ul>

                    </section>
                    <!--//section-->

                    <!-- Java Structure -->
                    <section class="docs-section" id="item-1-3">
                        <h1 class="docs-heading">
                            Java Structure
                        </h1>
                        <article>

                            <p>A quick, practical guide to how a basic Java program is organized‚Äîclasses, methods,
                                the <code>main</code> entry point, packages, and more.</p>

                            <section id="hello-world">
                                <h2>Minimal Program (‚ÄúHello, Java‚Äù)</h2>
                                <pre><code class="language-java">public class Main {
    // Program entry point
    public static void main(String[] args) {
        System.out.println("Hello, Java!");
    }
}</code></pre>
                                <ul>
                                    <li><strong>Class name:</strong> <code>Main</code> (must match the file name
                                        <code>Main.java</code>).
                                    </li>
                                    <li><strong>Entry point:</strong>
                                        <code>public static void main(String[] args)</code> ‚Äî where execution begins.
                                    </li>
                                    <li><strong>Output:</strong> <code>System.out.println(...)</code> writes to the
                                        console.</li>
                                </ul>
                            </section>

                            <section id="file-class">
                                <h2>Files, Classes, and Bytecode</h2>
                                <ol>
                                    <li>Write code in a file named after the <em>public</em> class (e.g.,
                                        <code>Main.java</code>).
                                    </li>
                                    <li>Compile: <code>javac Main.java</code> ‚Üí generates <code>Main.class</code>
                                        (bytecode).</li>
                                    <li>Run: <code>java Main</code> ‚Üí executes the bytecode on the JVM.</li>
                                </ol>
                                <p><em>Note:</em> A file can contain multiple classes, but at most one
                                    <code>public</code> class, and its name must match the file.
                                </p>
                                <br>
                            </section>

                            <section id="anatomy">
                                <h2>Program Anatomy</h2>
                                <div class="table-responsive my-4">
                                    <table class="table table-bordered">
                                        <thead>
                                            <tr>
                                                <th>Component</th>
                                                <th>Description</th>
                                                <th>Example</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td><strong>Package</strong></td>
                                                <td>Defines a namespace to organize related classes.</td>
                                                <td><code>package com.example.app;</code></td>
                                            </tr>
                                            <tr>
                                                <td><strong>Import Statement</strong></td>
                                                <td>Includes external classes or packages for use in your program.</td>
                                                <td><code>import java.util.Scanner;</code></td>
                                            </tr>
                                            <tr>
                                                <td><strong>Class Declaration</strong></td>
                                                <td>The blueprint that encapsulates data (fields) and behavior
                                                    (methods).</td>
                                                <td><code>public class Main { ... }</code></td>
                                            </tr>
                                            <tr>
                                                <td><strong>Main Method</strong></td>
                                                <td>The entry point of any Java program‚Äîexecution begins here.</td>
                                                <td><code>public static void main(String[] args) { ... }</code></td>
                                            </tr>
                                            <tr>
                                                <td><strong>Statements</strong></td>
                                                <td>Instructions executed by the JVM; each must end with a semicolon
                                                    (<code>;</code>).</td>
                                                <td><code>System.out.println("Hello, World!");</code></td>
                                            </tr>
                                            <tr>
                                                <td><strong>Comments</strong></td>
                                                <td>Used to describe or explain code without affecting execution.</td>
                                                <td><code>// This is a comment</code></td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </section>

                            <section id="java-execution">
                                <header>
                                    <h2>How Java Code Executes</h2>
                                    <p>This section explains the full journey from a <code>.java</code> source file to a
                                        running program on your machine.</p>
                                </header>

                                <figure style="margin:1rem 0;">
                                    <!-- Replace the src with your hosted image URL -->
                                    <img src="./assets/images/How-Java-Code-Executes.png"
                                        alt="Diagram showing the flow: HelloWorld.java ‚Üí Java Compiler ‚Üí HelloWorld.class ‚Üí JVM ‚Üí Program output"
                                        style="max-width:100%;height:auto;border-radius:8px;">
                                    <figcaption style="font-size:.95rem;color:#555;margin-top:.5rem;">
                                        Java source code is compiled to bytecode (<code>.class</code>) and executed by
                                        the JVM, which produces native machine instructions. Collected from
                                        GeeksforGeeks.
                                    </figcaption>
                                </figure>

                                <ol>
                                    <li>
                                        <h3>Write Source Code (<code>.java</code>)</h3>
                                        <p>You create a file such as <code>HelloWorld.java</code> that contains Java
                                            classes and methods.</p>
                                        <pre><code class="language-java">public class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello, Java!");
  }
}</code></pre>
                                    </li>

                                    <li>
                                        <h3>Compile with <code>javac</code></h3>
                                        <p>The Java compiler checks syntax and type rules, then converts source code
                                            into platform-independent <strong>bytecode</strong> stored in
                                            <code>.class</code> files.
                                        </p>
                                        <pre><code class="language-bash">javac HelloWorld.java   # produces HelloWorld.class</code></pre>
                                    </li>

                                    <li>
                                        <h3>Class Loading</h3>
                                        <p>When you run the program, the <strong>Class Loader</strong> loads required
                                            classes (<code>rt.jar</code>/modules, third-party libs, your classes) into
                                            memory.</p>
                                    </li>

                                    <li>
                                        <h3>Bytecode Verification</h3>
                                        <p>The <strong>Bytecode Verifier</strong> ensures the <code>.class</code> files
                                            are safe and follow JVM constraints (no illegal casts, stack overflows,
                                            etc.).</p>
                                    </li>

                                    <li>
                                        <h3>Execution in the JVM</h3>
                                        <p>The <strong>Execution Engine</strong> of the JVM runs the verified bytecode:
                                        </p>
                                        <ul>
                                            <li><strong>Interpreter</strong> quickly executes bytecode instructions one
                                                by one.</li>
                                            <li><strong>JIT (Just-In-Time) Compiler</strong> detects hot code paths and
                                                compiles them into native machine code for better performance.</li>
                                        </ul>
                                        <p>The JVM manages memory via the <strong>Heap</strong> and
                                            <strong>Stack</strong>, and reclaims unused objects using the
                                            <strong>Garbage Collector</strong>.
                                        </p>
                                    </li>

                                    <li>
                                        <h3>Program Output</h3>
                                        <p>After execution, your program produces output on the console, files, network,
                                            or UI.</p>
                                        <pre><code class="language-bash">java HelloWorld
# ‚Üí Hello, Java!</code></pre>
                                    </li>
                                </ol>

                                <aside
                                    style="background:#f8fafc;border:1px solid #e5e7eb;border-radius:8px;padding:12px;margin-top:16px;">
                                    <h2 style="margin:0 0 .5rem;">CLI Quick Reference</h2>
                                    <pre style="margin:0;"><code class="language-bash"># Compile a single file
javac HelloWorld.java

# Run a class (omit .class)
java HelloWorld

# With packages (run from project root)
javac com/example/app/App.java
java com.example.app.App</code></pre>
                                </aside>


                                <br>
                                <h2>Key Terms</h2>
                                <ul>
                                    <li><strong>JDK</strong>: Tools to compile and develop Java (includes
                                        <code>javac</code> and the JVM).
                                    </li>
                                    <li><strong>JRE</strong>: Environment to run Java apps (JVM + core libraries).
                                    </li>
                                    <li><strong>JVM</strong>: Virtual machine that executes bytecode on any
                                        platform.</li>
                                    <li><strong>Bytecode</strong>: Platform-independent instructions in
                                        <code>.class</code> files.
                                    </li>
                                    <li><strong>JIT</strong>: Compiles hot bytecode paths into native code at
                                        runtime.</li>
                                </ul>

                            </section>


                            <section id="packages-imports">
                                <h2>Packages &amp; Imports</h2>
                                <pre><code class="language-java">package com.acme.app;            // Directory: com/acme/app
import java.util.ArrayList;      // Single class
import java.util.*;              // Wildcard (use sparingly)

public class App {
	public static void main(String[] args) {
		ArrayList<String> items = new ArrayList<>();
		items.add("Java");
		System.out.println(items);
	}
}</code></pre>
                                <ul>
                                    <li>Directory structure mirrors the package path (<code>com/acme/app</code>).</li>
                                    <li>Prefer specific imports over wildcards for clarity.</li>
                                </ul>

                            </section>

                            <section id="access-modifiers">
                                <h2>Access Modifiers &amp; Class Members</h2>
                                <pre><code class="language-java">public class Counter {
	// field (state)
	private int value;

	// constructor
	public Counter(int start) {
		this.value = start;
	}

	// instance method
	public void increment() {
		value++;
	}

	// static method (belongs to the class)
	public static Counter ofZero() {
		return new Counter(0);
	}

	// getter
	public int getValue() {
		return value;
	}

}
</code></pre>
                                <ul>
                                    <li><strong>public</strong>: visible everywhere; <strong>private</strong>: visible
                                        only inside the class.</li>
                                    <li><strong>static</strong> methods/fields belong to the class; instance members
                                        belong to objects.</li>
                                    <li>Use constructors to initialize new objects.</li>
                                </ul>

                            </section>

                            <section id="comments-formatting">
                                <h2>Comments &amp; Formatting</h2>
                                <pre><code class="language-java">/**
 * Calculator utilities.
 */
public class Calc {
    // Single-line comment
    public static int add(int a, int b) {
        return a + b;  // Inline comment (brief!)
    }
}</code></pre>
                                <ul>
                                    <li><strong>Javadoc</strong> (<code>/** ... */</code>) documents APIs and can be
                                        generated into HTML.</li>
                                    <li>Follow consistent indentation and braces style for readability.</li>
                                </ul>
                            </section>

                            <section id="conventions">
                                <h2>Naming &amp; Style Conventions</h2>
                                <ul>
                                    <li><strong>Classes/Interfaces:</strong> PascalCase (e.g.,
                                        <code>OrderService</code>).
                                    </li>
                                    <li><strong>Methods/Variables:</strong> camelCase (e.g., <code>placeOrder</code>,
                                        <code>maxCount</code>).
                                    </li>
                                    <li><strong>Constants:</strong> UPPER_SNAKE_CASE (e.g., <code>MAX_SIZE</code>).</li>
                                    <li><strong>One public class per file</strong>; file name = public class name +
                                        <code>.java</code>.
                                    </li>
                                </ul>
                            </section>

                            <section id="compile-run">
                                <h2>Compile &amp; Run (CLI)</h2>
                                <pre><code class="language-bash"># From the folder containing Main.java
javac Main.java     # compile ‚Üí Main.class
java Main           # run</code></pre>
                                <p>When using packages, compile/run from the project root:</p>
                                <pre><code class="language-bash">javac com/acme/app/App.java
java com.acme.app.App</code></pre>
                            </section>

                            <section id="errors">
                                <h2>Common Structure Errors</h2>
                                <ul>
                                    <li><strong>Class/file mismatch:</strong> Public class <code>App</code> must be in
                                        <code>App.java</code>.
                                    </li>
                                    <li><strong>Missing <code>main</code>:</strong> Applications need an entry point;
                                        libraries don‚Äôt.</li>
                                    <li><strong>Wrong package path:</strong> Package declaration must match folders.
                                    </li>
                                    <li><strong>Visibility issues:</strong> Accessing <code>private</code> members from
                                        outside the class.</li>
                                </ul>
                            </section>

                            <div>
                                <h2>Next Steps</h2>
                                <ol>
                                    <li>Create a new project and a class with <code>main</code>.</li>
                                    <li>Print some text, declare variables, and call a helper method.</li>
                                    <li>Refactor into multiple classes to practice files, packages, and imports.</li>
                                </ol>
                            </div>
                        </article>
                    </section>

                    <!-- Data Types -->
                    <section class="docs-section" id="item-1-4">
                        <h1 class="docs-heading">
                            Data Types
                        </h1>
                        <article>
                            <p>
                                In Java, <strong>data types</strong> define what kind of values a variable can hold and
                                how those values are stored and manipulated in memory.
                                Java is a <strong>statically typed</strong> and <strong>strongly typed</strong>
                                language, which means:
                            </p>
                            <ul>
                                <li>Every variable has a declared type at compile time.</li>
                                <li>Type conversions are explicit or follow well-defined rules.</li>
                            </ul>

                            <h2>High-Level Classification of Data Types</h2>
                            <ul>
                                <li><strong>Primitive Types</strong> ‚Äì built into the language, store simple values.
                                </li>
                                <li><strong>Reference Types</strong> ‚Äì objects, arrays, enums, interfaces, etc.</li>
                            </ul>

                            <h3>Primitive Data Types</h3>
                            <p>Java has 8 primitive data types:</p>
                            <ul>
                                <li><code>byte</code></li>
                                <li><code>short</code></li>
                                <li><code>int</code></li>
                                <li><code>long</code></li>
                                <li><code>float</code></li>
                                <li><code>double</code></li>
                                <li><code>char</code></li>
                                <li><code>boolean</code></li>
                            </ul>

                            <h3>1. Integer Types</h3>
                            <p>Used to store whole numbers (no decimal point).</p>

                            <h2><code>byte</code></h2>
                            <ul>
                                <li>Size: 8-bit signed integer.</li>
                                <li>Range: -128 to 127.</li>
                                <li>Use case: memory-sensitive contexts (large arrays of small numbers, streams, file
                                    I/O).</li>
                            </ul>
                            <pre><code>byte b = 100;
byte min = -128;
byte max = 127;</code></pre>

                            <h2><code>short</code></h2>
                            <ul>
                                <li>Size: 16-bit signed integer.</li>
                                <li>Range: -32,768 to 32,767.</li>
                                <li>Use case: rarely used; legacy code and some binary data formats.</li>
                            </ul>
                            <pre><code>short s = 32000;</code></pre>

                            <h2><code>int</code></h2>
                            <ul>
                                <li>Size: 32-bit signed integer.</li>
                                <li>Range: approx. -2.1 billion to 2.1 billion.</li>
                                <li><strong>Most commonly used</strong> integer type.</li>
                                <li>Default type for integer literals (e.g., <code>42</code> is an <code>int</code>).
                                </li>
                            </ul>
                            <pre><code>int count = 42;
int population = 1_000_000; // underscores for readability</code></pre>

                            <h2><code>long</code></h2>
                            <ul>
                                <li>Size: 64-bit signed integer.</li>
                                <li>Range: extremely large (~9.22e18).</li>
                                <li>Used when integer range of <code>int</code> is insufficient.</li>
                                <li>Requires <code>L</code> or <code>l</code> suffix for literals when exceeding
                                    <code>int</code> range.
                                </li>
                            </ul>
                            <pre><code>long big = 10_000_000_000L; // L is important</code></pre>

                            <h3>2. Floating-Point Types</h3>
                            <p>Used to represent numbers with fractional parts.</p>

                            <h4><code>float</code></h4>
                            <ul>
                                <li>Size: 32-bit IEEE 754 floating-point.</li>
                                <li>Precision: about 6‚Äì7 decimal digits.</li>
                                <li>Use case: large arrays of floating values where memory matters and some precision
                                    loss is acceptable.</li>
                                <li>Requires <code>f</code> or <code>F</code> suffix for literals.</li>
                            </ul>
                            <pre><code>float average = 3.14f; // 'f' or 'F' required</code></pre>

                            <h4><code>double</code></h4>
                            <ul>
                                <li>Size: 64-bit IEEE 754 floating-point.</li>
                                <li>Precision: about 15‚Äì16 decimal digits.</li>
                                <li><strong>Default type</strong> for floating-point literals (e.g., <code>3.14</code>
                                    is a <code>double</code>).</li>
                                <li>Most common floating-point type in Java.</li>
                            </ul>
                            <pre><code>double pi = 3.141592653589793;
double result = 1.0 / 3.0;</code></pre>

                            <h3>3. <code>char</code> Type</h3>
                            <ul>
                                <li>Size: 16-bit unsigned value.</li>
                                <li>Represents a single Unicode character.</li>
                                <li>Range: from <code>'\u0000'</code> to <code>'\uffff'</code>.</li>
                            </ul>
                            <pre><code>char letter = 'A';
char digit = '9';
char unicodeChar = '\u03A9'; // Greek capital letter Omega</code></pre>

                            <h3>4. <code>boolean</code> Type</h3>
                            <ul>
                                <li>Represents two values: <code>true</code> or <code>false</code>.</li>
                                <li>Commonly used in conditional statements and logical operations.</li>
                                <li>No defined size in the Java language specification (implementation-dependent).</li>
                            </ul>
                            <pre><code>boolean isJavaFun = true;
boolean isCold = false;</code></pre>

                            <h4>Reference (Non-Primitive) Data Types</h4>
                            <p>Reference types refer to objects stored in the heap. The variable holds a
                                <strong>reference</strong> (similar to an address) to the object.
                            </p>

                            <h3>1. Classes and Objects</h3>
                            <p>Any class you define is a reference type:</p>
                            <pre><code>class Person {
    String name;
    int age;
}

Person p = new Person();
p.name = "Alice";
p.age = 30;</code></pre>
                            <ul>
                                <li>Default value for an uninitialized reference field is <code>null</code>.</li>
                                <li>Accessing a member on a <code>null</code> reference throws
                                    <code>NullPointerException</code>.
                                </li>
                            </ul>

                            <h3>2. <code>String</code></h3>
                            <ul>
                                <li><code>String</code> is a <strong>reference type</strong>, not primitive.</li>
                                <li>Strings are <strong>immutable</strong>.</li>
                                <li>Literals are created with double quotes: <code>"Hello"</code>.</li>
                            </ul>
                            <pre><code>String message = "Hello, Java!";
String another = new String("Hello, Java!"); // usually not needed</code></pre>

                            <h3>3. Arrays</h3>
                            <ul>
                                <li>Arrays are objects and thus reference types.</li>
                                <li>They have a fixed length once created.</li>
                            </ul>
                            <pre><code>int[] numbers = new int[5];      // all elements initialized to 0
int[] values  = {1, 2, 3, 4, 5}; // array literal

System.out.println(values.length); // 5</code></pre>

                            <h3>4. Enums</h3>
                            <p>Enums are special reference types representing a fixed set of constants.</p>
                            <pre><code>enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

Day today = Day.MONDAY;</code></pre>

<h4>Enums in Java Overview</h4>
<p>Enums in Java are used to represent a fixed set of named constants, making your code safer, more readable, and easier to maintain, especially when you want to restrict possible values a variable can take, such as days of the week, months, colors, or predefined states in a system.</p>

<h4>Common Use Cases for Enum in Java</h4>

<h3>Representing Fixed Categories</h3>
<p>Enums help define a set of constant values like days (MONDAY to SUNDAY), levels (LOW, MEDIUM, HIGH), ticket categories (CRITICAL, HIGH, MEDIUM, LOW), or seasons (WINTER, SPRING, SUMMER, AUTUMN).</p>

<h3>Control Flow Statements</h3>
<p>Enums are widely used in switch-case and if-else statements, for handling logic based on these named values. This improves code clarity and reduces errors from using arbitrary numbers or strings.</p>

<h3>Type Safety</h3>
<p>They ensure type safety by restricting values to those defined in the enum, unlike traditional final static constants which can be any value.</p>

<h3>Grouping Related Constants</h3>
<p>Useful for grouping constants related by context, for example, status codes, user roles, or configuration options in applications.</p>

<h4>Example of Using Enum</h4>
<pre>
    <code  class="language-java">enum TicketCategory {
    CRITICAL, HIGH, MEDIUM, LOW;
}

public class Main {
    public static void main(String[] args) {
        TicketCategory category = TicketCategory.HIGH;
        switch (category) {
            case CRITICAL:
                System.out.println("Critical ticket");
                break;
            case HIGH:
                System.out.println("High priority ticket");
                break;
            case MEDIUM:
                System.out.println("Medium priority ticket");
                break;
            case LOW:
                System.out.println("Low priority ticket");
                break;
        }
    }
}
</code>
</pre>
<p>This code demonstrates how enums define constant categories and integrate smoothly with control statements like switch, improving code reliability and readability.</p>

<h4>Advanced Use</h4>

<h3>Enums with Methods and Fields</h3>
<p>Enums in Java can have methods, fields, and constructors, enabling them to store and operate on more complex data, such as associating a value or description with each constant.</p>

<h3>Interface Implementation</h3>
<p>Enums can implement interfaces to provide flexible code design patterns, such as providing descriptions or custom behaviors for each constant.</p>

<h4>Conclusion</h4>
<p>Overall, enums in Java are preferred whenever you need a variable to accept only a predetermined set of constant values, ensuring code safety and ease of maintenance.</p>




                            <h3>5. Interfaces, Records, and Other Reference Types</h3>
                            <ul>
                                <li><strong>Interfaces</strong> define contracts; implementation classes are reference
                                    types.</li>
                                <li><strong>Records</strong> (Java 16+) are special classes for immutable data carriers.
                                </li>
                            </ul>
                            <pre><code>record Point(int x, int y) {}

Point p = new Point(10, 20); // x=10, y=20</code></pre>
<p>In Java 16 and later, you can use a record to simplify classes that are mainly data carriers. A record automatically provides private final fields, a constructor, getters, equals(), hashCode(), and toString() methods, which greatly reduces boilerplate code.s</p>

                            <h4>Wrapper Classes and Autoboxing</h4>

                            <p>Each primitive type has a corresponding wrapper class in <code>java.lang</code>:</p>
                            <ul>
                                <li><code>byte</code> ‚Üí <code>Byte</code></li>
                                <li><code>short</code> ‚Üí <code>Short</code></li>
                                <li><code>int</code> ‚Üí <code>Integer</code></li>
                                <li><code>long</code> ‚Üí <code>Long</code></li>
                                <li><code>float</code> ‚Üí <code>Float</code></li>
                                <li><code>double</code> ‚Üí <code>Double</code></li>
                                <li><code>char</code> ‚Üí <code>Character</code></li>
                                <li><code>boolean</code> ‚Üí <code>Boolean</code></li>
                            </ul>

                            <h4>Autoboxing and Unboxing</h4>
                            <p>
                                <strong>Autoboxing</strong> is automatic conversion from primitive to wrapper type.
                                <strong>Unboxing</strong> is the reverse.
                            </p>
                            <pre><code>Integer a = 10;   // autoboxing: int to Integer
int b = a;        // unboxing: Integer to int

List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(5);      // autoboxing
int x = list.get(0); // unboxing</code></pre>
                            <p><strong>Common pitfall:</strong> unboxing a <code>null</code> wrapper will throw
                                <code>NullPointerException</code>.
                            </p>
                            <pre><code>Integer n = null;
int y = n; // throws NullPointerException</code></pre>

                            <h4>Type Conversion and Casting</h4>

                            <h5>Widening Primitive Conversions (Safe, Implicit)</h5>
                            <p>Small type ‚Üí larger type, done automatically.</p>
                            <ul>
                                <li><code>byte ‚Üí short ‚Üí int ‚Üí long ‚Üí float ‚Üí double</code></li>
                                <li><code>char ‚Üí int ‚Üí long ‚Üí float ‚Üí double</code></li>
                            </ul>
                            <pre><code>int i = 100;
long l = i;       // OK, widening
double d = l;     // OK, widening</code></pre>

                            <h5>Narrowing Primitive Conversions (Explicit, Risky)</h5>
                            <p>Large type ‚Üí smaller type, requires explicit cast and may lose data.</p>
                            <pre><code>long big = 130L;
byte b = (byte) big; // overflow: result is -126

double v = 3.9;
int k = (int) v;     // k = 3, fractional part lost</code></pre>

                            <h5>Reference Type Casting</h5>
                            <p>
                                You can cast references within an inheritance hierarchy. Incorrect casts cause
                                <code>ClassCastException</code> at runtime.
                            </p>
                            <pre><code>Object obj = "Hello";
String str = (String) obj;      // OK

Object obj2 = Integer.valueOf(10);
String s = (String) obj2;       // ClassCastException at runtime</code></pre>

                            <h4>Default Values</h4>
                            <p>Default values apply to <strong>fields</strong> (instance or static), not to local
                                variables.</p>
                            <ul>
                                <li><code>byte, short, int, long</code> ‚Üí <code>0</code></li>
                                <li><code>float, double</code> ‚Üí <code>0.0</code></li>
                                <li><code>char</code> ‚Üí <code>'\u0000'</code></li>
                                <li><code>boolean</code> ‚Üí <code>false</code></li>
                                <li>Any reference type ‚Üí <code>null</code></li>
                            </ul>
                            <pre><code>class Example {
    int number;       // default 0
    boolean flag;     // default false
    String text;      // default null
}</code></pre>
                            <p>Local variables <strong>must</strong> be initialized before use or the code will not
                                compile.</p>

                            <h4>Newer Language Features Related to Types (Recent Java Versions)</h4>
                            <p>While the primitive data types themselves have not changed, newer Java versions added
                                features that affect how types are used and inferred.</p>

                            <h5>1. Local Variable Type Inference (<code>var</code>, Java 10+)</h5>
                            <p>
                                Java allows <code>var</code> for local variables, where the type is inferred by the
                                compiler.
                                <strong>Important:</strong> the variable still has a static type; <code>var</code> is
                                <em>not</em> dynamic typing.
                            </p>
                            <pre><code>var n = 10;          // inferred as int
var text = "Hello";  // inferred as String

// Still type-safe:
text = 20;           // compile-time error</code></pre>

                            <h5>2. Text Blocks for Strings (Java 13+)</h5>
                            <p>Multi-line string literals using <code>"""</code> are still <code>String</code> type.</p>
                            <pre><code>String json = """
{
  "name": "Alice",
  "age": 30
}
""";</code></pre>

                            <h5>3. Records (Java 16+)</h5>
                            <p>Records provide a concise syntax for classes that are mainly data carriers.</p>
                            <pre><code>record User(String name, int age) {}

User u = new User("Bob", 25);
String name = u.name();
int age = u.age();</code></pre>

                            <h5>4. Pattern Matching for <code>instanceof</code> (Java 16+)</h5>
                            <p>Makes type checking and casting more concise.</p>
                            <pre><code>Object obj = "Hello";
if (obj instanceof String s) {
    System.out.println(s.toUpperCase());
}</code></pre>

                            <h4>Common Exceptions Related to Data Types</h4>

                            <ul>
                                <li><strong><code>NullPointerException</code></strong>
                                    <ul>
                                        <li>Occurs when accessing a member or method on a <code>null</code> reference.
                                        </li>
                                    </ul>
                                    <pre><code>String s = null;
int len = s.length(); // NullPointerException</code></pre>
                                </li>

                                <li><strong><code>ClassCastException</code></strong>
                                    <ul>
                                        <li>Occurs when an invalid type cast is performed on a reference.</li>
                                    </ul>
                                    <pre><code>Object obj = Integer.valueOf(10);
String s = (String) obj; // ClassCastException</code></pre>
                                </li>

                                <li><strong><code>NumberFormatException</code></strong>
                                    <ul>
                                        <li>Occurs when converting a string to a numeric type fails.</li>
                                    </ul>
                                    <pre><code>int n = Integer.parseInt("abc"); // NumberFormatException</code></pre>
                                </li>

                                <li><strong><code>ArrayIndexOutOfBoundsException</code></strong>
                                    <ul>
                                        <li>Occurs when accessing an array index outside its bounds.</li>
                                    </ul>
                                    <pre><code>int[] arr = {1, 2, 3};
int x = arr[3]; // ArrayIndexOutOfBoundsException, valid indexes: 0..2</code></pre>
                                </li>

                                <li><strong><code>ArithmeticException</code></strong>
                                    <ul>
                                        <li>Commonly occurs on integer division by zero.</li>
                                    </ul>
                                    <pre><code>int a = 10;
int b = 0;
int c = a / b; // ArithmeticException: / by zero</code></pre>
                                </li>
                            </ul>

                            <h4>Most Commonly Mistaken Concepts About Java Data Types</h4>

                            <h5>1. <code>==</code> vs <code>equals()</code></h5>
                            <ul>
                                <li><code>==</code> compares <strong>references</strong> for objects (same memory
                                    location).</li>
                                <li><code>equals()</code> compares <strong>contents</strong> (if properly overridden).
                                </li>
                            </ul>
                            <pre><code>String a = new String("Java");
String b = new String("Java");

System.out.println(a == b);        // false (different objects)
System.out.println(a.equals(b));   // true (same content)</code></pre>

                            <h5>2. Treating <code>String</code> as a Primitive</h5>
                            <ul>
                                <li><code>String</code> is not primitive; it is a class in <code>java.lang</code>.</li>
                                <li>It behaves like a value in many scenarios, but it's still a reference.</li>
                            </ul>

                            <h5>3. Floating-Point Precision</h5>
                            <ul>
                                <li><code>float</code> and <code>double</code> are imprecise for some decimal values.
                                </li>
                                <li>Use <code>BigDecimal</code> for precise financial calculations.</li>
                            </ul>
                            <pre><code>double x = 0.1 + 0.2;
System.out.println(x); // may print 0.30000000000000004</code></pre>

                            <h5>4. Integer Division</h5>
                            <ul>
                                <li>Dividing two integers performs <strong>integer division</strong>, discarding the
                                    fractional part.</li>
                            </ul>
                            <pre><code>int a = 5;
int b = 2;
int c = a / b;    // 2, not 2.5
double d = a / b; // 2.0, still integer division first

double correct = a / 2.0; // 2.5</code></pre>

                            <h5>5. Overflow and Underflow</h5>
                            <ul>
                                <li>Primitive integer types (<code>byte</code>, <code>short</code>, <code>int</code>,
                                    <code>long</code>) overflow silently.
                                </li>
                            </ul>
                            <pre><code>int max = Integer.MAX_VALUE; // 2147483647
int overflow = max + 1;      // -2147483648 (wraps around)</code></pre>

                            <h5>6. Confusing <code>char</code> with <code>String</code></h5>
                            <ul>
                                <li><code>char</code> uses single quotes, <code>String</code> uses double quotes.</li>
                                <li><code>char</code> is a single 16-bit code unit, <code>String</code> is a sequence of
                                    characters.</li>
                            </ul>
                            <pre><code>char c = 'A';
String s = "A";</code></pre>

                            <h5>7. Assuming Arrays Grow Dynamically</h5>
                            <ul>
                                <li>Arrays in Java have fixed length.</li>
                                <li>To have dynamic growth, use collections like <code>ArrayList</code>.</li>
                            </ul>
                            <pre><code>int[] arr = new int[3];
// arr.length is always 3

List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(1);
list.add(2);
// list size can grow dynamically</code></pre>

                            <h5>8. Misusing Autoboxing and Caching</h5>
                            <p>
                                Wrapper classes cache some values (e.g., <code>Integer</code> from -128 to 127),
                                which can lead to confusion when using <code>==</code>.
                            </p>
                            <pre><code>Integer x = 127;
Integer y = 127;
System.out.println(x == y); // true (cached)

Integer m = 128;
Integer n = 128;
System.out.println(m == n); // false (different objects)
System.out.println(m.equals(n)); // true</code></pre>

                            <h5>9. Thinking <code>var</code> Means Dynamic Typing</h5>
                            <ul>
                                <li><code>var</code> does <strong>not</strong> mean the type can change.</li>
                                <li>Type is inferred once at compile time and cannot change later.</li>
                            </ul>

                            <h4>Best Practices When Working with Data Types in Java</h4>
                            <ul>
                                <li>Prefer <code>int</code> and <code>double</code> for general numeric work unless you
                                    have a specific reason to use others.</li>
                                <li>Use <code>long</code> for large ranges (e.g., IDs, timestamps).</li>
                                <li>Use <code>BigInteger</code> and <code>BigDecimal</code> for very large numbers or
                                    precise decimal arithmetic.</li>
                                <li>Avoid excessive autoboxing in performance-critical code (e.g., in loops) to reduce
                                    object creation.</li>
                                <li>Always check for <code>null</code> before unboxing wrapper types.</li>
                                <li>Use <code>equals()</code> to compare object content (especially
                                    <code>String</code>), not <code>==</code>.
                                </li>
                                <li>Be cautious with floating-point equality comparisons; use tolerances (epsilon)
                                    instead.</li>
                                <li>Initialize local variables before use; do not rely on defaults.</li>
                            </ul>

                            <h4>Summary</h4>
                            <p>
                                Java data types are divided into <strong>primitive</strong> and
                                <strong>reference</strong> types.
                                Understanding their sizes, ranges, default values, conversions, and common pitfalls is
                                essential for writing correct and efficient Java programs.
                                While newer Java versions have introduced features like <code>var</code>, records, text
                                blocks, and pattern matching, the core set of primitive types remains unchanged.
                            </p>
                        </article>
                    </section>
                    <!-- Variables -->
                    <section class="docs-section" id="item-1-5">
                        <h1 class="docs-heading">
                            Variables
                        </h1>
                        <article>
                            <p>
                                In Java, a <strong>variable</strong> is a named storage location in memory that holds a
                                value.
                                Java is <strong>statically typed</strong>, which means every variable has a declared
                                type
                                known at compile time.
                            </p>

                            <h4>Key Characteristics of Java Variables</h4>
                            <ul>
                                <li>Each variable has a <strong>name</strong>, a <strong>type</strong>, and a
                                    <strong>value</strong>.
                                </li>
                                <li>Type determines what operations can be performed on the variable.</li>
                                <li>Variables have <strong>scope</strong> (where they are visible) and
                                    <strong>lifetime</strong> (how long they exist).
                                </li>
                                <li>Java variables must be <strong>declared</strong> before use.</li>
                            </ul>

                            <h4>Basic Syntax</h4>
                            <pre><code>&lt;type&gt; &lt;variableName&gt; [= initialValue] ;

int count;
int age = 25;
String name = "Alice";</code></pre>

                            <ul>
                                <li><strong>Declaration</strong>: tells the compiler the type and name of the variable.
                                </li>
                                <li><strong>Initialization</strong>: gives the variable an initial value.</li>
                            </ul>

                            <h4>Classification of Variables</h4>

                            <h5>By Data Type</h5>
                            <ul>
                                <li><strong>Primitive type variables</strong> ‚Äì hold primitive values like
                                    <code>int</code>, <code>double</code>, <code>boolean</code>, etc.
                                </li>
                                <li><strong>Reference type variables</strong> ‚Äì hold references (addresses) to objects
                                    (e.g., <code>String</code>, arrays, custom classes).</li>
                            </ul>

                            <h5>By Scope / Where They Are Declared</h5>
                            <ul>
                                <li><strong>Local variables</strong> ‚Äì declared inside methods, constructors, or blocks.
                                </li>
                                <li><strong>Parameter variables</strong> ‚Äì declared in method or constructor parameter
                                    lists.</li>
                                <li><strong>Instance variables (fields)</strong> ‚Äì non-static fields declared in a
                                    class.</li>
                                <li><strong>Static variables (class variables)</strong> ‚Äì fields declared with
                                    <code>static</code>.
                                </li>
                            </ul>

                            <h4>Local Variables</h4>
                            <p>Local variables are declared inside methods, constructors, or blocks and exist only
                                within that scope.</p>
                            <pre><code>void doSomething() {
    int x = 10;           // local variable
    if (x &gt; 5) {
        int y = 20;       // local to the if-block
        System.out.println(y);
    }
    // y is not visible here
}</code></pre>

                            <ul>
                                <li>No default values ‚Äì <strong>must</strong> be initialized before use (otherwise
                                    compile-time error).</li>
                                <li>Stored on the <strong>stack</strong> (conceptually) and destroyed when the method
                                    finishes.</li>
                            </ul>

                            <h4>Parameter Variables</h4>
                            <p>
                                Parameters are variables declared in a method or constructor‚Äôs parameter list. They
                                receive values when the method is called.
                            </p>
                            <pre><code>void greet(String name, int times) {  // name and times are parameters
    for (int i = 0; i &lt; times; i++) {
        System.out.println("Hello " + name);
    }
}</code></pre>

                            <ul>
                                <li>Parameters are treated like local variables inside the method.</li>
                                <li>They must have a type and a name.</li>
                            </ul>

                            <h4>Instance Variables (Fields)</h4>
                            <p>Instance variables belong to an <strong>object</strong> (instance of the class).</p>
                            <pre><code>class Person {
    String name;    // instance variable
    int age;        // instance variable

    void introduce() {
        System.out.println("My name is " + name);
    }
}</code></pre>

                            <ul>
                                <li>Each object has its own copy of instance variables.</li>
                                <li>Default values apply if not initialized explicitly (e.g., 0, <code>false</code>,
                                    <code>null</code>).
                                </li>
                                <li>Accessible via <code>this.name</code>, though <code>this</code> is usually optional.
                                </li>
                            </ul>

                            <h4>Static Variables (Class Variables)</h4>
                            <p>Static variables belong to the <strong>class itself</strong>, not to any particular
                                object.</p>
                            <pre><code>class Counter {
    static int count = 0; // static variable

    Counter() {
        count++;
    }
}

Counter c1 = new Counter();
Counter c2 = new Counter();
System.out.println(Counter.count); // 2</code></pre>

                            <ul>
                                <li>Shared among all instances of the class.</li>
                                <li>Accessed via class name: <code>ClassName.variableName</code>.</li>
                                <li>Useful for constants and shared state (e.g., caches, counters).</li>
                            </ul>

                            <h4>Variable Initialization</h4>

                            <h5>1. Explicit Initialization</h5>
                            <pre><code>int x = 10;
String message = "Hello";</code></pre>

                            <h5>2. Default Initialization (Fields Only)</h5>
                            <pre><code>class Example {
    int n;         // default 0
    boolean flag;  // default false
    String text;   // default null
}</code></pre>

                            <p>Local variables <strong>do not</strong> get default values and must be initialized before
                                use.</p>

                            <h5>3. Multiple Declarations</h5>
                            <pre><code>int a, b, c;
int x = 1, y = 2, z = 3;</code></pre>

                            <p>For clarity, it is often better to declare one variable per line.</p>

                            <h4>Final Variables (Constants)</h4>
                            <p>A <code>final</code> variable can be assigned only once.</p>
                            <pre><code>final int MAX_SIZE = 100;
final String APP_NAME = "MyApp";</code></pre>

                            <ul>
                                <li>After assignment, the value cannot be changed.</li>
                                <li>For reference types, the <strong>reference</strong> cannot change, but the object it
                                    points to may be mutable.</li>
                            </ul>
                            <pre><code>final List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add("A");    // OK, modifying the object
// list = new ArrayList&lt;&gt;(); // Error: cannot assign a value to final variable</code></pre>

                            <h4>Blank Final Variables</h4>
                            <p>Final variables that are declared but not initialized immediately, typically assigned in
                                the constructor.</p>
                            <pre><code>class User {
    final String id; // blank final

    User(String id) {
        this.id = id; // must be assigned here
    }
}</code></pre>

                            <h4>Effectively Final Variables</h4>
                            <p>
                                A variable is <strong>effectively final</strong> if it is assigned only once, even
                                without the <code>final</code> keyword.
                                This is important for anonymous classes and lambdas.
                            </p>
                            <pre><code>void test() {
    int base = 10; // effectively final
    Runnable r = () -&gt; System.out.println(base); // allowed
}</code></pre>

                            <h4>Local Variable Type Inference (<code>var</code>, Java 10+)</h4>
                            <p>
                                Java supports <strong>local variable type inference</strong> using <code>var</code> for
                                local variables
                                with initializers. The type is inferred by the compiler.
                            </p>

                            <pre><code>var number = 10;           // inferred as int
var text = "Hello";        // inferred as String
var list = new ArrayList&lt;String&gt;(); // inferred as ArrayList&lt;String&gt;</code></pre>

                            <ul>
                                <li><code>var</code> can only be used for <strong>local variables</strong>,
                                    <strong>for-each</strong> variables, and <strong>traditional for-loop</strong>
                                    indices.
                                </li>
                                <li>Cannot be used for fields, method parameters, or return types.</li>
                                <li>Variable still has a single, static type ‚Äì Java is <strong>not</strong> dynamically
                                    typed.</li>
                                <li>Requires an initializer (you cannot write just <code>var x;</code>).</li>
                            </ul>

                            <pre><code>// Invalid uses:
var x;                    // Error: cannot use 'var' without initializer
var nothing = null;       // Error: cannot infer type from null alone</code></pre>

                            <h4>Naming Variables</h4>
                            <ul>
                                <li>Use <strong>camelCase</strong> for variables and methods: <code>totalAmount</code>,
                                    <code>userName</code>.
                                </li>
                                <li>Use <strong>UPPER_SNAKE_CASE</strong> for <code>static final</code> constants:
                                    <code>MAX_VALUE</code>.
                                </li>
                                <li>Names must start with a letter, <code>$</code>, or <code>_</code>, and can contain
                                    digits after that.</li>
                                <li>Avoid using <code>$</code> and <code>_</code> unless you have a special reason.</li>
                                <li>Must not be a Java keyword (like <code>int</code>, <code>class</code>,
                                    <code>for</code>).
                                </li>
                            </ul>

                            <h4>Scope and Lifetime</h4>

                            <h5>1. Block Scope</h5>
                            <pre><code>if (condition) {
    int a = 10;   // a is visible only inside this block
}
// a is not visible here</code></pre>

                            <h5>2. Method Scope</h5>
                            <p>Local variables declared in a method are not visible outside that method.</p>

                            <h5>3. Class Scope</h5>
                            <p>Instance and static variables are visible to all methods of the class (subject to access
                                modifiers).</p>

                            <h4>Shadowing</h4>
                            <p>
                                A local or parameter variable can <strong>shadow</strong> a field with the same name.
                                Use <code>this</code> to refer to the field.
                            </p>
                            <pre><code>class Example {
    int value;

    Example(int value) {
        this.value = value; // 'this.value' is the field, 'value' is parameter
    }
}</code></pre>

                            <h4>Variables and Memory</h4>
                            <ul>
                                <li><strong>Local variables and parameters</strong> live on the stack (conceptually) and
                                    are destroyed when the method returns.</li>
                                <li><strong>Instance and static variables</strong> are part of objects or class metadata
                                    stored on the heap.</li>
                                <li>Reference variables hold an address pointing to an object on the heap.</li>
                            </ul>

                            <h4>Common Errors and Exceptions Related to Variables</h4>

                            <h5>Compile-Time Errors (Not Exceptions)</h5>
                            <ul>
                                <li><strong>"variable might not have been initialized"</strong> ‚Äì using a local variable
                                    before assigning a value.</li>
                                <li><strong>"cannot find symbol"</strong> ‚Äì using a variable name that is out of scope
                                    or not declared.</li>
                                <li><strong>"variable x is already defined in method"</strong> ‚Äì declaring two variables
                                    with the same name in the same scope.</li>
                            </ul>

                            <pre><code>void example() {
    int x;
    // System.out.println(x); // Error: variable x might not have been initialized
}</code></pre>

                            <h5>Runtime Exceptions (Caused by Incorrect Use of Variables)</h5>
                            <ul>
                                <li><strong>NullPointerException</strong> ‚Äì using a reference variable that is
                                    <code>null</code>.
                                </li>
                                <li><strong>ArrayIndexOutOfBoundsException</strong> ‚Äì using an array index outside the
                                    valid range.</li>
                                <li><strong>ClassCastException</strong> ‚Äì incorrect casting of objects referenced by
                                    variables.</li>
                            </ul>

                            <pre><code>String s = null;
s.length(); // NullPointerException

int[] arr = new int[3];
arr[3] = 10; // ArrayIndexOutOfBoundsException</code></pre>

                            <h4>Most Commonly Mistaken Concepts About Variables in Java</h4>

                            <h5>1. Java Is Pass-by-Value (Always)</h5>
                            <p>
                                Many people think objects are passed by reference. In reality, Java passes the
                                <strong>value of the reference</strong> (a copy of the reference).
                            </p>
                            <pre><code>void modify(int x) {
    x = 10;
}

void modify(StringBuilder sb) {
    sb.append(" world");
}

int a = 5;
modify(a);
System.out.println(a); // still 5

StringBuilder sb = new StringBuilder("Hello");
modify(sb);
System.out.println(sb); // Hello world</code></pre>
                            <p>
                                Changing the reference variable itself does not affect the caller, but modifying
                                the object it points to does.
                            </p>

                            <h5>2. Confusing <code>=</code> with <code>==</code></h5>
                            <ul>
                                <li><code>=</code> is <strong>assignment</strong>.</li>
                                <li><code>==</code> is <strong>comparison</strong>.</li>
                            </ul>

                            <h5>3. Using <code>==</code> for Strings and Objects</h5>
                            <p>
                                <code>==</code> compares whether two reference variables point to the <strong>same
                                    object</strong>,
                                not whether their values are equal. Use <code>equals()</code> for value equality.
                            </p>
                            <pre><code>String a = new String("Java");
String b = new String("Java");

System.out.println(a == b);      // false (different objects)
System.out.println(a.equals(b)); // true (same content)</code></pre>

                            <h5>4. Assuming Local Variables Have Default Values</h5>
                            <p>Local variables <strong>must</strong> be initialized before use; there are no automatic
                                defaults.</p>

                            <h5>5. Misunderstanding <code>static</code> vs Instance Variables</h5>
                            <ul>
                                <li>Static variables are shared across all instances.</li>
                                <li>Instance variables are unique to each object.</li>
                            </ul>
                            <p>Accidentally using static variables for per-object state leads to bugs.</p>

                            <h5>6. Thinking <code>var</code> Makes Java Dynamically Typed</h5>
                            <ul>
                                <li>With <code>var</code>, the compiler still decides a single, fixed type at compile
                                    time.</li>
                                <li>You cannot assign a different type later.</li>
                            </ul>
                            <pre><code>var x = 10;  // int
// x = "Hello"; // Error: incompatible types</code></pre>

                            <h5>7. Variable Shadowing Confusion</h5>
                            <p>Forgetting that a local or parameter variable shadows a field can lead to unexpected
                                behavior.</p>
                            <pre><code>class Demo {
    int value = 5;

    void setValue(int value) {
        value = value;        // assigns parameter to itself, field unchanged
    }
}</code></pre>
                            <p>Correct version uses <code>this</code>:</p>
                            <pre><code>void setValue(int value) {
    this.value = value;       // assigns parameter to field
}</code></pre>

                            <h4>Newer Language Features Related to Variables</h4>

                            <h5>1. <code>var</code> (Java 10+)</h5>
                            <ul>
                                <li>Reduces verbosity in local variable declarations.</li>
                                <li>Particularly useful with generics and complex types.</li>
                            </ul>

                            <h5>2. Pattern Variables in <code>instanceof</code> (Java 16+)</h5>
                            <p>
                                Pattern matching introduces <strong>pattern variables</strong> that combine type tests
                                and casts.
                            </p>
                            <pre><code>Object obj = "Hello";
if (obj instanceof String s) { // s is a pattern variable
    System.out.println(s.toUpperCase());
}</code></pre>

                            <h5>3. Pattern Matching for <code>switch</code> (Newer Java Versions)</h5>
                            <p>
                                Enhanced <code>switch</code> expressions and pattern matching introduce variables bound
                                in
                                <code>case</code> labels, making code more expressive while still being statically
                                typed.
                            </p>

                            <h4>Best Practices for Variables in Java</h4>
                            <ul>
                                <li>Use <strong>meaningful names</strong> that clearly describe the purpose of the
                                    variable.</li>
                                <li>Keep variable <strong>scope as small as possible</strong> to reduce bugs and improve
                                    readability.</li>
                                <li>Prefer <strong>immutable</strong> variables where possible (<code>final</code> and
                                    effectively final).</li>
                                <li>Avoid using magic numbers; use <strong>constants</strong>
                                    (<code>static final</code>) instead.</li>
                                <li>Initialize variables close to where they are used.</li>
                                <li>Be careful with <strong>static</strong> variables; overuse can lead to tight
                                    coupling and hidden dependencies.</li>
                                <li>Use <code>var</code> when it improves readability, not just to save typing.</li>
                            </ul>



                            <h4>Summary</h4>
                            <p>
                                Variables in Java are fundamental building blocks that represent named storage locations
                                associated with types.
                                Understanding the different kinds of variables (local, parameter, instance, static),
                                their scope, lifetime,
                                initialization rules, and how they interact with newer language features like
                                <code>var</code> and pattern matching
                                is essential to writing clean, correct, and maintainable Java code. Many common bugs
                                arise from misunderstandings
                                about variable scope, initialization, and object references, so paying attention to
                                these details is critical.
                            </p>


                            <h4>Type Casting in Java</h4>

                            <p>
                                <strong>Type casting</strong> in Java means converting a value of one data type into
                                another compatible data type.
                                There are two main categories:
                            </p>
                            <ul>
                                <li><strong>Primitive casting</strong> (between <code>int</code>, <code>double</code>,
                                    etc.)</li>
                                <li><strong>Reference casting</strong> (between classes in the same inheritance
                                    hierarchy)</li>
                            </ul>

                            <h5>1. Primitive Type Casting</h5>

                            <h6>1.1 Widening Casting (Automatic / Implicit)</h6>
                            <p>
                                Small type ‚Üí bigger type. This is safe and done automatically by Java.
                            </p>
                            <p><strong>Order:</strong> <code>byte ‚Üí short ‚Üí int ‚Üí long ‚Üí float ‚Üí double</code></p>
                            <pre><code>int i = 10;
double d = i;   // int to double (automatic)
long  l = i;    // int to long   (automatic)</code></pre>

                            <h3>1.2 Narrowing Casting (Manual / Explicit)</h3>
                            <p>
                                Bigger type ‚Üí smaller type. This can lose data, so you must cast
                                <strong>explicitly</strong>
                                using <code>(targetType)</code>.
                            </p>
                            <pre><code>double d = 9.7;
int i = (int) d;   // i = 9, fractional part is lost

long  big = 130L;
byte  b   = (byte) big; // overflow, b = -126</code></pre>

                            <p><strong>Syntax:</strong></p>
                            <pre><code>&lt;targetType&gt; variable = (&lt;targetType&gt;) value;</code></pre>

                            <h3>1.3 Common Examples</h3>
                            <pre><code>float f = 3.14f;
double d = f;           // widening, OK

double x = 3.99;
int    y = (int) x;     // narrowing, need (int)

short s = 100;
byte  bb = (byte) s;    // narrowing, need (byte)</code></pre>

                            <h3>1.4 Casting vs Parsing (for Strings)</h3>
                            <p>
                                You <strong>cannot</strong> cast a <code>String</code> directly to a number. Use parsing
                                methods:
                            </p>
                            <pre><code>String s = "123";
// int n = (int) s;       // ‚ùå compile error

int n = Integer.parseInt(s);   // ‚úî correct
double d = Double.parseDouble("3.14");</code></pre>

                            <h2>2. Reference Type Casting (Objects)</h2>

                            <p>
                                For reference types, you can cast only within the same <strong>inheritance
                                    hierarchy</strong>.
                                There are two concepts:
                            </p>
                            <ul>
                                <li><strong>Upcasting</strong> ‚Äì child ‚Üí parent (implicit)</li>
                                <li><strong>Downcasting</strong> ‚Äì parent ‚Üí child (explicit, may fail at runtime)</li>
                            </ul>

                            <h3>2.1 Upcasting (Safe, Automatic)</h3>
                            <pre><code>class Animal {
    void speak() { System.out.println("Animal"); }
}

class Dog extends Animal {
    void bark() { System.out.println("Woof"); }
}

Dog d = new Dog();
Animal a = d;    // upcasting: Dog ‚Üí Animal (automatic)</code></pre>

                            <p>
                                Upcasting is always safe because a <code>Dog</code> <em>is an</em> <code>Animal</code>.
                            </p>

                            <h3>2.2 Downcasting (Manual, Can Throw Exception)</h3>
                            <p>
                                Downcasting means casting a parent reference back to a child type. You must do it
                                explicitly, and it
                                can throw <code>ClassCastException</code> if the actual object is not of that type.
                            </p>
                            <pre><code>Animal a = new Dog();      // upcast
Dog d = (Dog) a;           // downcast, OK at runtime

Animal a2 = new Animal();
// Dog d2 = (Dog) a2;      // compiles, but at runtime: ClassCastException</code></pre>

                            <h3>2.3 Use <code>instanceof</code> Before Downcasting</h3>
                            <p>
                                To avoid <code>ClassCastException</code>, you should check with <code>instanceof</code>:
                            </p>
                            <pre><code>Animal a = getAnimal();  // returns some Animal

if (a instanceof Dog) {
    Dog d = (Dog) a;     // safe downcast
    d.bark();
} else {
    System.out.println("Not a Dog");
}</code></pre>

                            <h3>2.4 Pattern Matching <code>instanceof</code> (Newer Java)</h3>
                            <p>Modern Java lets you combine <code>instanceof</code> and cast:</p>
                            <pre><code>if (a instanceof Dog d) {
    d.bark();   // d is already a Dog
}</code></pre>

                            <h2>3. Important Notes About Casting</h2>
                            <ul>
                                <li>Casting does <strong>not change</strong> the variable‚Äôs declared type, only the
                                    value in that expression.</li>
                            </ul>
                            <pre><code>double d = 5.9;
int x = (int) d;  // cast only here
// d is still double, only x is int</code></pre>

                            <ul>
                                <li>You can only cast between <strong>compatible</strong> types (same hierarchy for
                                    objects, numeric types for primitives).</li>
                                <li>Casting does <strong>not</strong> create a new object for reference types; it just
                                    treats the same object as another type.</li>
                            </ul>

                            <h2>4. Quick Cheat Sheet</h2>
                            <ul>
                                <li><strong>Primitive widening</strong> ‚Äì automatic:
                                    <code>int i = 10; double d = i;</code></li>
                                <li><strong>Primitive narrowing</strong> ‚Äì need cast:
                                    <code>double d = 9.8; int i = (int) d;</code></li>
                                <li><strong>Upcasting (child ‚Üí parent)</strong> ‚Äì automatic:
                                    <code>Animal a = new Dog();</code></li>
                                <li><strong>Downcasting (parent ‚Üí child)</strong> ‚Äì explicit:
                                    <code>Dog d = (Dog) a;</code></li>
                                <li><strong>Strings to numbers</strong> ‚Äì use <code>parseInt</code>,
                                    <code>parseDouble</code>, etc., not casting.</li>
                                <li>Use <code>instanceof</code> to check before downcasting to avoid
                                    <code>ClassCastException</code>.</li>
                            </ul>
                        </article>
                    </section>


                    <!--//section-->
                </article>
            </div>
        </div>


    </div>





    <!-- Javascript -->
    <script src="assets/plugins/popper.min.js"></script>
    <script src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>

    <!-- Page Specific JS -->
    <script src="assets/plugins/smoothscroll.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
    <script src="assets/js/highlight-custom.js"></script>
    <script src="assets/plugins/simplelightbox/simple-lightbox.min.js"></script>
    <script src="assets/plugins/gumshoe/gumshoe.polyfills.min.js"></script>
    <script src="assets/js/docs.js"></script>

</body>

</html>