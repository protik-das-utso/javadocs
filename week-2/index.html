<!DOCTYPE html>
<html lang="en">

<head>
    <title>
        Java Documentation - Protik The DEV
    </title>

    <!-- Meta -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Java Documentation For Software Developers" />
    <meta name="author" content="Protik The DEV" />
    <link rel="shortcut icon" href="../favicon.png" />

    <!-- Google Font -->
    <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet" />

    <!-- FontAwesome JS-->
    <script defer src="../assets/fontawesome/js/all.min.js"></script>

    <!-- Plugins CSS -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.2/styles/atom-one-dark.min.css" />
    <link rel="stylesheet" href="../assets/plugins/simplelightbox/simple-lightbox.min.css" />
    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="../assets/css/theme.css" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-TCN8REREGW"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-TCN8REREGW');
    </script>
</head>

<body>

    <header class="header fixed-top">
        <div class="branding docs-branding">
            <div class="container-fluid position-relative py-2">
                <div class="docs-logo-wrapper">
                    <button id="docs-sidebar-toggler" class="docs-sidebar-toggler docs-sidebar-visible me-2 d-xl-none"
                        type="button">
                        <span></span>
                        <span></span>
                        <span></span>
                    </button>
                    <div class="site-logo">
                        <a class="navbar-brand" href="index.html"><img class="logo-icon me-2" src="../favicon.png"
                                alt="logo" width="50px" /><span class="logo-text">Java <span
                                    class="text-alt">Documentation</span></span></a>
                    </div>
                </div>
                <!--//docs-logo-wrapper-->
                <div class="docs-top-utilities d-flex justify-content-end align-items-center">
                    <!-- Include Lunr.js -->
                    <script src="https://unpkg.com/lunr/lunr.js"></script>
                    <!-- Your search form -->
                    <div class="top-search-box d-none d-lg-flex">
                        <form class="search-form" id="searchForm">
                            <input type="text" placeholder="Search the docs..." name="search"
                                class="form-control search-input" id="searchInput" />
                            <button type="submit" class="btn search-btn" value="Search">
                                <i class="fas fa-search"></i>
                            </button>
                        </form>
                    </div>

                    <ul class="social-list list-inline mx-md-3 mx-lg-5 mb-0 d-none d-lg-flex">
                        <li class="list-inline-item">
                            <a href="https://github.com/protik-das-utso" target="_blank"><i
                                    class="fa-brands fa-github fa-fw"></i></a>
                        </li>
                        <li class="list-inline-item">
                            <a href="https://t.me/protikthedev" target="_blank"><i
                                    class="fa-brands fa-telegram fa-fw"></i></a>
                        </li>
                        <li class="list-inline-item">
                            <a href="http://facebook.com/protikthedeveloper" target="_blank"><i
                                    class="fa-brands fa-facebook fa-fw"></i></a>
                        </li>
                        <li class="list-inline-item">
                            <a href="https://www.youtube.com/@protikthedev" target="_blank"><i
                                    class="fa-brands fa-youtube fa-fw"></i></a>
                        </li>
                    </ul>
                    <!--//social-list-->
                    <a href="https://t.me/protikthedev" target="_blank" class="btn btn-primary d-none d-lg-flex">Join
                        Telegram</a>
                </div>
                <!--//docs-top-utilities-->
            </div>
            <!--//container-->
        </div>
        <!--//branding-->
    </header>
    <!--//header-->

    <div class="docs-wrapper">

        <div id="docs-sidebar" class="docs-sidebar">
            <div class="top-search-box d-lg-none p-3">
                <form class="search-form">
                    <input type="text" placeholder="Search the docs..." name="search"
                        class="form-control search-input" />
                    <button type="submit" class="btn search-btn" value="Search">
                        <i class="fas fa-search"></i>
                    </button>
                </form>
            </div>
            <nav id="docs-nav" class="docs-nav navbar">
                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title">
                        <a class="nav-link" href="../week-1/"><span class="theme-icon-holder me-2"><i
                                    class="fas fa-map-signs"></i></span>Week 1</a>
                    </li>
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link active" href="#week-2"><span class="theme-icon-holder me-2"><i
                                    class="fas fa-arrow-down"></i></span>Week 2</a>
                    </li>

                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-1" b style="color: red;">Class 4 - Recording</a>
                    </li>

                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-2">Methods & Parameters</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-3">Return Types & Overloading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-5">Exceptions & Methods</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-6">Core Method Concepts</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-7">Advanced Method Topics</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-8">Complete Example & Best Practices</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-9" b style="color: red;">Class 5 - Recording</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-10">Arrays & String Manipulation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-11" b style="color: red;">Class 6 - Recording</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-12">Class</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-13">Objects</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-14">Constructors</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-15" b style="color: red;">Class 7 - Recording</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-16">Inheritance</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-17">Polymorphism</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-2-18">Encapsulation</a>
                    </li>

                </ul>
            </nav>
            <!--//docs-nav-->
        </div>


        <!--//docs-sidebar-->
        <div class="docs-content">
            <div class="container">
                <article class="docs-article" id="week-2">
                    <header class="docs-header">
                        <h1 class="docs-heading">Week 2 - Methods & Parameters</h1>
                        <!-- Search Results -->
                        <div id="searchResults"></div>
                        <script>
                            document.addEventListener('DOMContentLoaded', function () {
                                if (typeof lunr === 'undefined') {
                                    console.error('Lunr.js not found. Load https://unpkg.com/lunr/lunr.js before this script.');
                                    return;
                                }

                                // ----------------------------
                                // 1) Utilities
                                // ----------------------------
                                const scope = document.querySelector('.docs-content') || document;
                                const isHeading = n => n && /^H[1-6]$/.test(n.tagName);
                                const levelBoost = { H1: 12, H2: 8, H3: 5, H4: 3, H5: 2 };

                                // Normalize for case/diacritics to keep searching standard & user-friendly
                                const normalize = s =>
                                    (s || '')
                                        .normalize('NFKD')
                                        .replace(/[\u0300-\u036f]/g, '')   // strip accents
                                        .replace(/\s+/g, ' ')
                                        .trim();

                                function snippetFrom(el, limit = 260) {
                                    let txt = '';
                                    let n = el.nextElementSibling;
                                    while (n && txt.length < limit) {
                                        if (n.nodeType === 1) {
                                            if (isHeading(n)) break;
                                            txt += (n.textContent || '') + ' ';
                                        }
                                        n = n.nextElementSibling;
                                    }
                                    return txt.trim().substring(0, limit);
                                }

                                // ----------------------------
                                // 2) Collect headings and build index
                                // ----------------------------
                                const headings = Array.from(scope.querySelectorAll('h1.docs-heading, h2, h3'));
                                const docs = headings.map((h, i) => {
                                    const id = h.id || `heading-${i}`;
                                    if (!h.id) h.id = id;

                                    const level = parseInt(h.tagName[1]);
                                    const title = h.textContent || '';
                                    const snippet = snippetFrom(h);

                                    return {
                                        id,
                                        title: normalize(title),
                                        snippet: normalize(snippet),
                                        level,
                                        element: h
                                    };
                                });

                                if (docs.length === 0) {
                                    console.warn('No h1.docs-heading, h2, or h3 found to index.');
                                    return;
                                }

                                // Build Lunr index
                                const idx = lunr(function () {
                                    this.ref('id');
                                    this.field('title', { boost: 10 });
                                    this.field('snippet', { boost: 1 });
                                    docs.forEach(doc => this.add(doc));
                                });

                                // ----------------------------
                                // 3) Search functionality
                                // ----------------------------
                                function performSearch(query) {
                                    if (!query.trim()) {
                                        document.getElementById('searchResults').innerHTML = '';
                                        return;
                                    }

                                    const results = idx.search(query);
                                    const resultsContainer = document.getElementById('searchResults');

                                    if (results.length === 0) {
                                        resultsContainer.innerHTML = '<div class="alert alert-info">No results found.</div>';
                                        return;
                                    }

                                    const html = results.slice(0, 10).map(result => {
                                        const doc = docs.find(d => d.id === result.ref);
                                        if (!doc) return '';

                                        const boost = levelBoost[`H${doc.level}`] || 1;
                                        const adjustedScore = (result.score * boost).toFixed(2);

                                        return `
                                            <div class="search-result" style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">
                                                <h5><a href="#${doc.id}" style="text-decoration: none;">${doc.element.textContent}</a></h5>
                                                <p style="margin: 5px 0; color: #666; font-size: 0.9em;">${doc.snippet}</p>
                                                <small style="color: #999;">Score: ${adjustedScore} | Level: H${doc.level}</small>
                                            </div>
                                        `;
                                    }).join('');

                                    resultsContainer.innerHTML = html;
                                }

                                // ----------------------------
                                // 4) Attach to search inputs
                                // ----------------------------
                                const searchInputs = document.querySelectorAll('.search-input');
                                searchInputs.forEach(input => {
                                    input.addEventListener('input', e => performSearch(e.target.value));
                                });

                                console.log(`Lunr index built with ${docs.length} headings.`);
                            });
                        </script>
                    </header>

                    <section class="docs-section" id="item-2-1">
                        <h1 class="docs-heading">
                            Class 4 - Recording
                        </h1>
                        <a href="https://www.youtube.com/watch?v=hisGrirLjc4" target="_blank" class="full-width-btn">
                            ▶ Watch Video
                        </a>

                    </section>


                    <!-- Methods Introduction -->
                    <section class="docs-section" id="item-2-2">
                        <h1 class="docs-heading">Methods &amp; Parameters in Java</h1>

                        <p>
                            A <strong>method</strong> in Java is a reusable block of code that performs a specific task.
                            Methods help you organize logic, reduce duplication, and make your programs easier to read
                            and maintain.
                        </p>

                        <h2>1. What Is a Method?</h2>
                        <p>General syntax of a method:</p>

                        <pre><code>[access_modifier] [other_modifiers] return_type methodName(parameter_list) throws ExceptionType {
    // method body
}</code></pre>

                        <h3>1.1 Basic Example</h3>
                        <p>
                            This method takes two integers and returns their sum. It can be called multiple times with
                            different values.
                        </p>

                        <pre><code>public int add(int a, int b) {
    return a + b;
}

// Example usage:
int result = add(5, 3);   // result = 8</code></pre>

                        <!-- 2. PARAMETERS -->
                        <h2>2. Parameters and Arguments</h2>

                        <h3>2.1 Parameter vs Argument</h3>
                        <ul>
                            <li><strong>Parameter</strong> – the variable in the method definition.</li>
                            <li><strong>Argument</strong> – the actual value passed when calling the method.</li>
                        </ul>

                        <pre><code>public void greet(String name) {   // 'name' is a parameter
    System.out.println("Hello, " + name);
}

// Example usage:
greet("Tech Tiger");                // "Tech Tiger" is an argument
// Output: Hello, Tech Tiger</code></pre>

                        <h3>2.2 Java Is Pass-by-Value (Very Important Concept)</h3>
                        <p>
                            Java is always <strong>pass-by-value</strong>. That means the method receives a
                            <em>copy</em> of the value. For objects, the value being copied is a <em>reference</em> to
                            the object.
                        </p>

                        <h4>2.2.1 Primitive Example (cannot change original)</h4>
                        <pre><code>public static void changeValue(int x) {
    x = 99;  // changes only the local copy
}

public static void main(String[] args) {
    int a = 10;
    changeValue(a);
    System.out.println(a); // Output: 10 (still 10, not 99)
}</code></pre>

                        <p>
                            The variable <code>a</code> in <code>main</code> does not change because the method received
                            a copy of its value.
                        </p>

                        <h4>2.2.2 Reference Example (can change object state)</h4>
                        <pre><code>class Person {
    String name;
}

public static void rename(Person p) {
    p.name = "New Name";   // changes the object referenced by p
}

public static void main(String[] args) {
    Person person = new Person();
    person.name = "Old Name";

    rename(person);
    System.out.println(person.name);  // Output: New Name
}</code></pre>

                        <p>
                            Here the <strong>reference value</strong> is copied into the method, but both references
                            point to the same object,
                            so changing <code>p.name</code> affects <code>person.name</code>.
                        </p>

                        <h3>2.3 Varargs (<code>...</code>)</h3>
                        <p>
                            Varargs allow you to pass <strong>0 or more</strong> arguments of the same type to a method.
                        </p>

                        <pre><code>public static int sum(int... numbers) {
    int total = 0;
    for (int n : numbers) {
        total += n;
    }
    return total;
}

public static void main(String[] args) {
    System.out.println(sum());              // Output: 0  (no args)
    System.out.println(sum(1, 2, 3));       // Output: 6
    System.out.println(sum(10, 20, 30, 40));// Output: 100
}</code></pre>

                        <ul>
                            <li>Only one vararg parameter is allowed per method.</li>
                            <li>It must be the <strong>last</strong> parameter in the list.</li>
                        </ul>

                        <h3>2.4 <code>final</code> Parameters</h3>
                        <p>
                            Using <code>final</code> in parameters prevents reassigning the parameter variable inside
                            the method.
                            It does <strong>not</strong> make the object itself immutable.
                        </p>

                        <pre><code>public void process(final String input) {
    // input = "something else"; // ❌ Compile-time error
    System.out.println(input);
}</code></pre>

                    </section>
                    <!--//section-->

                    <!-- Return Types & Method Overloading -->
                    <section class="docs-section" id="item-2-3">
                        <h1 class="docs-heading">Return Types &amp; Method Overloading</h1>

                        <h2>3. Return Types</h2>
                        <p>
                            Every non-<code>void</code> method must return a value that matches its declared return
                            type.
                        </p>

                        <pre><code>public double divide(int a, int b) {
    if (b == 0) {
        throw new IllegalArgumentException("Divider cannot be zero");
    }
    return (double) a / b;
}

public void printHello() {          // returns nothing
    System.out.println("Hello");
}</code></pre>

                        <p>
                            If your method has a return type (like <code>int</code>, <code>double</code>, etc.),
                            you <strong>must</strong> return a value on every execution path.
                        </p>

                        <!-- 4. METHOD OVERLOADING -->
                        <h2>4. Method Overloading</h2>
                        <p>
                            <strong>Overloading</strong> means having multiple methods with the same name but different
                            parameter lists
                            (different number of parameters, types, or their order).
                        </p>

                        <pre><code>public int multiply(int a, int b) {
    return a * b;
}

public double multiply(double a, double b) {
    return a * b;
}

public int multiply(int a, int b, int c) {
    return a * b * c;
}

public static void main(String[] args) {
    System.out.println(multiply(2, 3));        // Output: 6        (int version)
    System.out.println(multiply(2.5, 3.0));    // Output: 7.5      (double version)
    System.out.println(multiply(2, 3, 4));     // Output: 24       (three-arg version)
}</code></pre>

                        <p>
                            Java decides which overload to call at <strong>compile time</strong>, based on the argument
                            types.
                        </p>

                    </section>
                    <!--//section-->


                    <!-- Exceptions and Methods -->
                    <section class="docs-section" id="item-2-5">
                        <h1 class="docs-heading">Exceptions and Methods</h1>

                        <h2>5. Exceptions and Methods</h2>
                        <p>
                            Methods can signal error conditions using <strong>exceptions</strong>. They can either
                            handle exceptions internally (with
                            <code>try-catch</code>) or declare that they throw them using the <code>throws</code>
                            clause.
                        </p>

                        <h3>5.1 Declaring Exceptions with <code>throws</code></h3>
                        <pre><code>import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public void readFile(String path) throws IOException {
    Files.readAllLines(Paths.get(path));  // may throw IOException
}

public void doWork() {
    try {
        readFile("data.txt");
        System.out.println("File read successfully.");
    } catch (IOException e) {
        System.out.println("Error reading file: " + e.getMessage());
    }
}</code></pre>

                        <h3>5.2 Checked vs Unchecked Exceptions</h3>
                        <ul>
                            <li><strong>Checked exceptions</strong> (subclasses of <code>Exception</code> except
                                <code>RuntimeException</code>) must be handled or declared.
                            </li>
                            <li><strong>Unchecked exceptions</strong> (subclasses of <code>RuntimeException</code>) do
                                not need to be declared.</li>
                        </ul>

                        <pre><code>public int parse(String s) {
    // NumberFormatException is an unchecked exception (RuntimeException)
    return Integer.parseInt(s);
}

public static void main(String[] args) {
    System.out.println(parse("123")); // OK
    System.out.println(parse("abc")); // Throws NumberFormatException at runtime
}</code></pre>

                    </section>
                    <!--//section-->

                    <!-- Core Method Concepts -->
                    <section class="docs-section" id="item-2-6">
                        <h1 class="docs-heading">Core Method Concepts</h1>

                        <h2>6. Core Method Concepts</h2>

                        <h3>6.1 Static vs Instance Methods</h3>
                        <p>
                            <strong>Static methods</strong> belong to the class; <strong>instance methods</strong>
                            belong to an object.
                        </p>

                        <pre><code>class MathUtil {

    // Static method (no instance required)
    public static int square(int x) {
        return x * x;
    }

    // Instance method (needs an object)
    public int triple(int x) {
        return 3 * x;
    }
}

public static void main(String[] args) {
    // Call static method
    System.out.println(MathUtil.square(4)); // Output: 16

    // Call instance method
    MathUtil util = new MathUtil();
    System.out.println(util.triple(4));     // Output: 12
}</code></pre>

                        <h3>6.2 Scope and the Call Stack</h3>
                        <p>
                            Variables declared inside a method are <strong>local</strong> to that method and exist only
                            while the method runs.
                        </p>

                        <pre><code>public void demo() {
    int x = 10;            // local variable
    System.out.println(x); // Output: 10
} // x is destroyed after this method finishes</code></pre>

                        <p>
                            Each method call creates a new <strong>stack frame</strong>. Deep or infinite recursion can
                            cause
                            <code>StackOverflowError</code>.
                        </p>

                        <h3>6.3 Recursion Example</h3>
                        <pre><code>public static int factorial(int n) {
    if (n &lt; 0) {
        throw new IllegalArgumentException("n must be &gt;= 0");
    }
    if (n == 0 || n == 1) {
        return 1;               // base case
    }
    return n * factorial(n - 1);// recursive call
}

public static void main(String[] args) {
    System.out.println(factorial(5)); // Output: 120
}</code></pre>

                    </section>
                    <!--//section-->

                    <!-- Advanced Method Topics -->
                    <section class="docs-section" id="item-2-7">
                        <h1 class="docs-heading">Advanced Method Topics</h1>

                        <h2>7. Interesting &amp; Lesser-Known Topics</h2>

                        <h3>7.1 Covariant Return Types</h3>
                        <p>
                            When overriding a method, the subclass can return a <strong>more specific</strong> type (a
                            subtype of the original return type).
                        </p>

                        <pre><code>class Animal {}

class Dog extends Animal {}

class AnimalFactory {
    Animal create() {
        return new Animal();
    }
}

class DogFactory extends AnimalFactory {
    @Override
    Dog create() {          // covariant return type (Dog is a subclass of Animal)
        return new Dog();
    }
}</code></pre>

                        <p>
                            This allows code that uses <code>DogFactory</code> to directly get a <code>Dog</code>
                            without casting.
                        </p>

                        <h3>7.2 Method References &amp; Lambdas</h3>
                        <p>
                            Methods can be treated like values using <strong>method references</strong>, often used with
                            streams and collections.
                        </p>

                        <pre><code>import java.util.Arrays;
import java.util.List;

public class MethodRefDemo {

    public static void printUpper(String s) {
        System.out.println(s.toUpperCase());
    }

    public static void main(String[] args) {
        List&lt;String&gt; names = Arrays.asList("java", "python", "kotlin");

        // Using lambda
        names.forEach(s -&gt; MethodRefDemo.printUpper(s));

        // Using method reference
        names.forEach(MethodRefDemo::printUpper);
        // Output:
        // JAVA
        // PYTHON
        // KOTLIN
    }
}</code></pre>

                        <h3>7.3 Default Methods in Interfaces</h3>
                        <p>
                            Interfaces can have <strong>default method implementations</strong>, which helps add new
                            behavior without breaking existing classes.
                        </p>

                        <pre><code>interface Logger {
    default void log(String msg) {
        System.out.println("[LOG] " + msg);
    }
}

class Service implements Logger {
    public void doWork() {
        log("Service started");
    }
}

public class Main {
    public static void main(String[] args) {
        Service s = new Service();
        s.doWork();  // Output: [LOG] Service started
    }
}</code></pre>

                        <h3>7.4 Overloading with Varargs (Ambiguity)</h3>
                        <p>
                            Overloading and varargs can create confusing situations. The compiler picks the <strong>most
                                specific</strong> method.
                        </p>

                        <pre><code>public void print(int x) {
    System.out.println("int");
}

public void print(Integer... x) {
    System.out.println("Integer varargs");
}

public static void main(String[] args) {
    Example e = new Example();
    e.print(5);  // Output: int  (primitive int is more specific)
}</code></pre>

                        <h3>7.5 Shadowing and Hiding</h3>
                        <p>
                            A parameter or local variable can <strong>shadow</strong> a field with the same name.
                        </p>

                        <pre><code>class Example {
    int value = 10;

    public void show(int value) {
        System.out.println(value);      // parameter
        System.out.println(this.value); // field
    }
}

public static void main(String[] args) {
    Example e = new Example();
    e.show(5);
    // Output:
    // 5
    // 10
}</code></pre>

                        <p>
                            Static methods are <strong>hidden</strong>, not overridden:
                        </p>

                        <pre><code>class A {
    static void hello() {
        System.out.println("Hello from A");
    }
}

class B extends A {
    static void hello() {
        System.out.println("Hello from B");
    }
}

public static void main(String[] args) {
    A a = new B();
    a.hello(); // Output: Hello from A (decided by reference type A)
}</code></pre>

                        <h3>7.6 Reflection: Calling Methods Dynamically</h3>
                        <p>
                            Reflection lets you inspect and invoke methods at runtime, even if you didn't know them at
                            compile time.
                            This is used heavily in frameworks (e.g., Spring), but it can be slower and harder to debug.
                        </p>

                        <pre><code>import java.lang.reflect.Method;

public class ReflectionDemo {
    public void sayHi(String name) {
        System.out.println("Hi, " + name);
    }

    public static void main(String[] args) throws Exception {
        ReflectionDemo obj = new ReflectionDemo();

        Class&lt;?&gt; clazz = obj.getClass();
        Method m = clazz.getMethod("sayHi", String.class);

        m.invoke(obj, "Tech Tiger"); // Output: Hi, Tech Tiger
    }
}</code></pre>

                    </section>
                    <!--//section-->

                    <!-- Complete Example & Best Practices -->
                    <section class="docs-section" id="item-2-8">
                        <h1 class="docs-heading">Complete Example &amp; Best Practices</h1>

                        <h2>8. Complete Example: Putting It All Together</h2>
                        <p>
                            This example combines several ideas: static methods, instance methods, parameters, return
                            values, exceptions,
                            and varargs.
                        </p>

                        <pre><code>public class MethodDocDemo {

    // Static utility method with exception
    public static double safeDivide(int a, int b) {
        if (b == 0) {
            throw new IllegalArgumentException("Divider cannot be zero");
        }
        return (double) a / b;
    }

    // Overloaded method with varargs
    public static int sum(int... values) {
        int total = 0;
        for (int v : values) {
            total += v;
        }
        return total;
    }

    // Instance method using recursion
    public int factorial(int n) {
        if (n &lt; 0) {
            throw new IllegalArgumentException("n must be &gt;= 0");
        }
        if (n == 0 || n == 1) {
            return 1;
        }
        return n * factorial(n - 1);
    }

    public static void main(String[] args) {
        // Using static method
        System.out.println("10 / 2 = " + safeDivide(10, 2)); // Output: 10 / 2 = 5.0

        // Using varargs method
        System.out.println("Sum = " + sum(1, 2, 3, 4, 5));   // Output: Sum = 15

        // Using instance method
        MethodDocDemo demo = new MethodDocDemo();
        System.out.println("Factorial(5) = " + demo.factorial(5)); // Output: 120
    }
}</code></pre>

                        <h2>Best Practices for Methods</h2>
                        <ul>
                            <li>Use descriptive method names that clearly indicate what the method does</li>
                            <li>Keep methods focused on a single task (Single Responsibility Principle)</li>
                            <li>Avoid too many parameters - consider using objects or builder patterns</li>
                            <li>Handle exceptions appropriately - use checked exceptions for recoverable errors</li>
                            <li>Document complex methods with JavaDoc comments</li>
                            <li>Make methods as simple and readable as possible</li>
                            <li>Use static methods for utility functions that don't depend on instance state</li>
                        </ul>
                    </section>

                    <section class="docs-section" id="item-2-9">
                        <h1 class="docs-heading">
                            Class 5 - Recording
                        </h1>
                        <a href="https://www.youtube.com/watch?v=IeLSvwjZSag" target="_blank" class="full-width-btn">
                            ▶ Watch Video
                        </a>

                    </section>

                    <!-- Arrays & String Manipulation  -->
                    <section class="docs-section" id="item-2-10">
                        <h1 class="docs-heading">Arrays & String Manipulation in Java</h1>

                        <h2>1. Arrays in Java</h2>
                        <p>
                            Arrays are one of the fundamental data structures in Java. They allow you to store multiple
                            values of the same data type under one variable name.
                            Arrays are fast, memory-efficient, and ideal when the number of elements is known
                            beforehand.
                            However, arrays are also fixed in size, meaning once you create them, you cannot increase or
                            decrease their length.
                        </p>

                        <h3>1.1 What is an Array?</h3>
                        <p>
                            An array is a sequence of values stored in contiguous memory locations. Each element can be
                            accessed using an index, starting from 0.
                            Arrays store elements of a single data type, such as integers, strings, or objects. Because
                            of their predictable structure,
                            arrays offer very fast access time—accessing any element is always O(1).
                        </p>
                        <pre><code>int[] numbers = new int[5]; // creates an array with 5 integer slots</code></pre>

                        <h3>1.2 Declaring and Initializing Arrays</h3>

                        <h4>Declaration</h4>
                        <p>
                            Declaring an array only tells Java to expect an array variable—it does not create memory
                            yet.
                            Declaring does not allocate space until you use the <code>new</code> keyword or assign a
                            literal array.
                        </p>
                        <pre><code>int[] arr;
int arr2[]; // valid but less preferred</code></pre>

                        <h4>Allocation</h4>
                        <p>
                            Allocation creates memory for a specific number of elements. The number you provide becomes
                            the array’s final size.
                        </p>
                        <pre><code>arr = new int[3]; // array of size 3</code></pre>

                        <h4>Declaration + Initialization</h4>
                        <p>
                            You can declare and populate an array in one step. This is common when you already know the
                            values.
                        </p>
                        <pre><code>int[] nums = {10, 20, 30};
String[] names = new String[] {"Alice", "Bob", "Charlie"};</code></pre>

                        <h3>1.3 Accessing and Updating Elements</h3>
                        <p>
                            Elements are accessed by index. Trying to access an index that does not exist results in an
                            exception.
                            The <code>length</code> field provides the total number of array elements.
                        </p>
                        <pre><code>int[] nums = {10, 20, 30};
int first = nums[0];   // 10
nums[1] = 99;          // update second element
int length = nums.length; // 3</code></pre>

                        <h3>1.4 Iterating Over Arrays</h3>

                        <h4>Classic for-loop</h4>
                        <p>
                            The traditional for-loop provides access to both the value and the index, which is helpful
                            when you need to modify specific elements or use their positions.
                        </p>
                        <pre><code>for (int i = 0; i &lt; nums.length; i++) {
    System.out.println("Index " + i + ": " + nums[i]);
}</code></pre>

                        <h4>Enhanced for-loop</h4>
                        <p>
                            Also known as the “for-each loop,” this version focuses only on values, making it ideal for
                            reading array elements without caring about indexes.
                        </p>
                        <pre><code>for (int value : nums) {
    System.out.println(value);
}</code></pre>

                        <h3>1.5 Multi-Dimensional Arrays</h3>
                        <p>
                            Java supports multi-dimensional arrays, which can be visualized as tables or grids. These
                            arrays are actually arrays of arrays.
                        </p>
                        <pre><code>int[][] matrix = new int[2][3]; // 2 rows, 3 columns</code></pre>

                        <h4>Jagged Arrays</h4>
                        <p>
                            Unlike some languages, Java allows different row lengths in multi-dimensional arrays. Such
                            arrays are called jagged arrays.
                            They give more flexibility and save memory if rows differ in size.
                        </p>
                        <pre><code>int[][] jagged = new int[3][];
jagged[0] = new int[]{1, 2};
jagged[1] = new int[]{3, 4, 5};
jagged[2] = new int[]{6};</code></pre>

                        <h3>1.6 Arrays Utility Class</h3>
                        <p>
                            The <code>java.util.Arrays</code> class provides powerful functions that save time and
                            reduce complexity.
                            These include sorting, searching, copying, filling, comparing, and converting arrays to
                            String.
                        </p>
                        <pre><code>Arrays.sort(nums); // ascending order
Arrays.copyOf(nums, 3); // copy first 3 elements
Arrays.fill(nums, 7); // fill array with value</code></pre>

                        <h3>1.7 Common Array Exceptions</h3>

                        <h4>ArrayIndexOutOfBoundsException</h4>
                        <p>
                            This occurs when you try to access an index outside valid boundaries (0 to length - 1).
                            It is one of the most common beginner errors.
                        </p>
                        <pre><code>nums[3]; // invalid if array has only 3 elements</code></pre>

                        <h4>NullPointerException</h4>
                        <p>
                            Happens when the array reference itself is null and you try to access properties or
                            elements.
                        </p>
                        <pre><code>int[] a = null;
a.length; // causes NPE</code></pre>

                        <h3>1.8 Less-Known Facts about Arrays</h3>
                        <ul>
                            <li>Arrays are full-fledged objects in Java—even <code>int[]</code> extends
                                <code>Object</code>.
                            </li>
                            <li>The <code>length</code> property of arrays is final, meaning array size cannot change
                                once created.</li>
                            <li>Java arrays are covariant, meaning <code>String[]</code> is a subtype of
                                <code>Object[]</code>, but this can cause runtime errors.
                            </li>
                            <li>Arrays of reference types store <code>null</code> by default.</li>
                        </ul>

                        <h2>2. Strings in Java</h2>
                        <p>
                            Strings are one of the most used data types in Java. A String represents a sequence of
                            characters,
                            and Java treats Strings as immutable objects. This immutability is a core design principle
                            that ensures security, thread safety, and optimization.
                        </p>

                        <h3>2.1 What is a String?</h3>
                        <p>
                            A String stores characters using UTF-16 encoding. Each character is stored in one or two
                            bytes, depending on its Unicode value.
                            Java stores String literals in a special area called the "String Pool" to reduce memory
                            usage and avoid duplicate objects.
                        </p>

                        <h3>2.2 Creating Strings</h3>
                        <p>
                            Strings can be created as literals or using the <code>new</code> keyword.
                            Literal Strings are stored in a shared pool, while <code>new String()</code> always creates
                            a fresh object on the heap.
                        </p>
                        <pre><code>String s1 = "Hello"; // uses String Pool
String s2 = new String("Hello"); // always new object</code></pre>

                        <h3>2.3 Basic String Operations</h3>

                        <h4>Concatenation</h4>
                        <p>Combining multiple strings:</p>
                        <pre><code>String c = "Hello" + " World";
String d = "Hello".concat(" World");</code></pre>

                        <h4>Length & Character Access</h4>
                        <pre><code>String str = "Java";
str.length(); // number of characters
str.charAt(1); // returns 'a'</code></pre>

                        <h4>Substring Extraction</h4>
                        <p>Creates a new string from a portion of an existing one:</p>
                        <pre><code>t.substring(0, 5);
t.substring(6);</code></pre>

                        <h4>Search Operations</h4>
                        <p>Locate characters or sequences inside the string:</p>
                        <pre><code>text.indexOf('a');
text.lastIndexOf("desh");</code></pre>

                        <h4>Replacing Text</h4>
                        <pre><code>"banana".replace("na","NA");</code></pre>

                        <h3>2.4 Comparing Strings</h3>

                        <h4>equals() vs ==</h4>
                        <p>
                            <code>==</code> compares object references, not content.
                            <code>equals()</code> compares character sequences.
                        </p>

                        <h4>Case-insensitive comparison</h4>
                        <pre><code>a.equalsIgnoreCase(b);</code></pre>

                        <h3>2.5 Useful String Methods</h3>
                        <ul>
                            <li><code>trim()</code> removes leading and trailing spaces.</li>
                            <li><code>toUpperCase()</code> and <code>toLowerCase()</code></li>
                            <li><code>startsWith()</code> and <code>endsWith()</code></li>
                            <li><code>contains()</code> to check substring existence.</li>
                            <li><code>split()</code> to convert text into array pieces.</li>
                            <li><code>isEmpty()</code> to check if length == 0.</li>
                        </ul>

                        <h3>2.6 StringBuilder & StringBuffer</h3>
                        <p>
                            Since Strings are immutable, frequent modifications (like inside loops) create many
                            unnecessary objects.
                            <code>StringBuilder</code> and <code>StringBuffer</code> solve this by providing mutable
                            character sequences.
                        </p>

                        <h4>StringBuilder (fast, not thread-safe)</h4>
                        <pre><code>StringBuilder sb = new StringBuilder();
sb.append("Hello").append(" World");</code></pre>

                        <h4>StringBuffer (thread-safe)</h4>
                        <pre><code>StringBuffer sbuf = new StringBuffer();
sbuf.append("Safe Threads");</code></pre>

                        <h3>2.7 Strings & Character Arrays</h3>
                        <p>
                            Converting to a char array is useful for low-level manipulation, like reversing strings or
                            masking passwords.
                        </p>
                        <pre><code>char[] chars = "Hello".toCharArray();
String rebuilt = new String(chars);</code></pre>

                        <h3>2.8 Common String Exceptions</h3>

                        <h4>StringIndexOutOfBoundsException</h4>
                        <p>Occurs when accessing an invalid index:</p>
                        <pre><code>"Java".charAt(4);</code></pre>

                        <h4>NullPointerException</h4>
                        <pre><code>String s = null;
s.length();</code></pre>

                        <h3>2.9 Less-Known String Facts</h3>
                        <ul>
                            <li>Strings are stored in the String Pool to save memory.</li>
                            <li>Strings are immutable, which increases security and reduces bugs.</li>
                            <li>Some characters require two <code>char</code> values due to UTF-16 surrogate pairs.</li>
                            <li><code>intern()</code> allows manual control of the String Pool.</li>
                        </ul>

                        <h2>3. Arrays & Strings Together</h2>

                        <h3>3.1 Splitting Strings into Arrays</h3>
                        <p>Useful for reading CSV data, parsing input, etc.</p>
                        <pre><code>String[] fruits = "apple,banana,orange".split(",");</code></pre>

                        <h3>3.2 Joining Arrays into Strings</h3>
                        <pre><code>String.join(" ", new String[]{"Java","is","fun"});</code></pre>

                        <h3>3.3 Reversing a String using Arrays</h3>
                        <pre><code>char[] c = "hello".toCharArray();
// reverse logic
String reversed = new String(c);</code></pre>

                        <h2>4. Best Practices Summary</h2>
                        <ul>
                            <li>Use arrays when the size is fixed and performance is critical.</li>
                            <li>Use ArrayList when size changes dynamically.</li>
                            <li>Always use <code>equals()</code> (not <code>==</code>) for string comparison.</li>
                            <li>Use StringBuilder for heavy string manipulation.</li>
                            <li>Always check for null before using string methods.</li>
                            <li>Prefer enhanced for-loop for readability.</li>
                            <li>Use <code>Arrays.toString()</code> for printing arrays.</li>
                        </ul>
                    </section>

                    <section class="docs-section" id="item-2-11">
                        <h1 class="docs-heading">
                            Class 6 - Recording
                        </h1>
                        <a href="https://www.youtube.com/watch?v=hisGrirLjc4" target="_blank" class="full-width-btn">
                            ▶ Watch Video
                        </a>

                    </section>

                    <!-- Class  -->
                    <section class="docs-section" id="item-2-12">

                        <!-- ========================================================= -->
                        <!-- ====================== CLASS SECTION ===================== -->
                        <!-- ========================================================= -->

                        <h1 class="docs-heading">Class in Java</h1>

                        <h2>Definition</h2>
                        <p>
                            A <strong>class</strong> in Java is a <em>blueprint/template</em> used to create objects.
                            It contains:
                        </p>
                        <ul>
                            <li>Variables (fields)</li>
                            <li>Methods (behaviors)</li>
                            <li>Constructors</li>
                            <li>Blocks</li>
                            <li>Inner classes</li>
                        </ul>

                        <h2>Simple Class Example</h2>
                        <pre><code class="language-java">
class Car {
    String brand;
    int speed;

    void run() {
        System.out.println(brand + " is running at " + speed + " km/h");
    }
}
</code></pre>

                        <h3>Real World Explanation</h3>
                        <p>
                            The <strong>Car</strong> class is like a <strong>car blueprint</strong>.
                            A blueprint is not a real car; it only describes what a car <em>should</em> have.
                        </p>
                        <ul>
                            <li><strong>brand</strong> → like "Toyota", "BMW"</li>
                            <li><strong>speed</strong> → how fast it can move</li>
                            <li><strong>run()</strong> → behavior of the car</li>
                        </ul>

                        <hr>

                        <h2>Types of Classes (All Types With Real-World Examples)</h2>

                        <h3>1. Concrete (Regular) Class</h3>
                        <pre><code class="language-java">
class Employee {
    String name;
    int id;
}
</code></pre>
                        <p><strong>Real World:</strong> A form used to create real employees.</p>

                        <h3>2. Abstract Class</h3>
                        <pre><code class="language-java">
abstract class Animal {
    abstract void sound();
}
</code></pre>
                        <p><strong>Real World:</strong> All animals make sounds, but each type defines its own.</p>

                        <h3>3. Final Class</h3>
                        <pre><code class="language-java">
final class Constants { }
</code></pre>
                        <p><strong>Real World:</strong> Sealed class — cannot be extended or modified.</p>

                        <h3>4. Static Nested Class</h3>
                        <pre><code class="language-java">
class Car {
    static class Engine {
        void info() { System.out.println("Engine info"); }
    }
}
</code></pre>
                        <p><strong>Real World:</strong> Department inside a company that works independently.</p>

                        <h3>5. Member Inner Class</h3>
                        <pre><code class="language-java">
class A {
    class B {
        void message() {
            System.out.println("Inner class B");
        }
    }
}
</code></pre>

                        <h3>6. Local Inner Class</h3>
                        <pre><code class="language-java">
class Shop {
    void bill() {
        class Item {
            String name;
        }
    }
}
</code></pre>
                        <p><strong>Real World:</strong> Temporary class used only while generating bill.</p>

                        <h3>7. Anonymous Inner Class</h3>
                        <pre><code class="language-java">
Runnable r = new Runnable() {
    public void run() {
        System.out.println("Running task");
    }
};
</code></pre>
                        <p><strong>Real World:</strong> A temporary worker hired for only one job.</p>

                        <h3>8. Enum Class</h3>
                        <pre><code class="language-java">
enum Direction { NORTH, SOUTH, EAST, WEST }
</code></pre>

                        <h3>9. POJO Class</h3>
                        <pre><code class="language-java">
class Student {
    private String name;
    private int age;
}
</code></pre>

                        <h3>10. Immutable Class</h3>
                        <pre><code class="language-java">
final class User {
    private final String username;
    User(String username) { this.username = username; }
    public String getUsername() { return username; }
}
</code></pre>

                        <h3>11. Singleton Class</h3>
                        <pre><code class="language-java">
class Singleton {
    private static Singleton obj = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return obj;
    }
}
</code></pre>

                        <hr>

                    </section>
                    <!-- Object-->
                    <section class="docs-section" id="item-2-13">
                        <h1 class="docs-heading">Objects</h1>

                        <h2>Definition</h2>
                        <p>
                            An <strong>object</strong> is a real instance of a class containing:
                        </p>
                        <ul>
                            <li><strong>State</strong> (variables)</li>
                            <li><strong>Behavior</strong> (methods)</li>
                            <li><strong>Identity</strong> (memory address)</li>
                        </ul>

                        <h2>Creating Objects (All Ways)</h2>

                        <h3>1. Using <code>new</code> keyword</h3>
                        <pre><code class="language-java">
Car c = new Car();
</code></pre>

                        <h3>2. Using Reflection</h3>
                        <pre><code class="language-java">
Car c = Car.class.newInstance();
</code></pre>

                        <h3>3. Using Constructor class</h3>
                        <pre><code class="language-java">
Constructor<Car> cons = Car.class.getConstructor();
Car c = cons.newInstance();
</code></pre>

                        <h3>4. Using clone()</h3>
                        <pre><code class="language-java">
Car c2 = (Car)c1.clone();
</code></pre>

                        <h3>5. Using Deserialization</h3>
                        <pre><code class="language-java">
Car c = (Car)ois.readObject();
</code></pre>

                        <h3>6. Anonymous Object</h3>
                        <pre><code class="language-java">
new Car().run();
</code></pre>

                        <h2>Memory Diagram</h2>
                        <pre>
Stack: c → reference
Heap: Object { brand="BMW", speed=180 }
Method Area: Class Car loaded
</pre>

                        <hr>
                    </section>
                    <!-- Constructor-->
                    <section class="docs-section" id="item-2-14">
                        <h1 class="docs-heading">Constructors in Java</h1>

                        <p>
                            A <strong>constructor</strong> in Java is a special block of code used to initialize an
                            object.
                            It runs automatically when an object is created and prepares the object with initial values.
                            It has the <strong>same name as the class</strong> and <strong>no return type</strong>.
                        </p>

                        <h2>Why Do We Need Constructors?</h2>
                        <p>
                            Constructors allow your object to start its life with proper and meaningful initial values.
                            Without constructors:
                        <ul>
                            <li>Objects would start uninitialized</li>
                            <li>We would do manual setup each time</li>
                            <li>Code becomes repetitive and error-prone</li>
                        </ul>
                        </p>

                        <hr>

                        <h2>Rules of Constructors</h2>
                        <ul>
                            <li>Constructor name must be the same as class name</li>
                            <li>No return type (not even <code>void</code>)</li>
                            <li>Called automatically when object is created</li>
                            <li>Cannot be <strong>static</strong>, <strong>final</strong>, or <strong>abstract</strong>
                            </li>
                            <li>Can be overloaded</li>
                            <li><strong>super()</strong> must be the first statement in constructor</li>
                            <li>If no constructor is written, JVM creates a <strong>default</strong> one</li>
                        </ul>

                        <hr>

                        <h2>Types of Constructors (All Types with Deep Explanation)</h2>

                        <!-- ========================================================= -->
                        <!-- =============== 1. DEFAULT (JVM PROVIDED) =============== -->
                        <!-- ========================================================= -->

                        <h3>1. Default Constructor (JVM Provided)</h3>

                        <p>
                            If you do not write any constructor, Java automatically provides a <strong>default
                                constructor</strong>
                            that sets all fields to default values specific to data types.
                        </p>

                        <pre><code class="language-java">
class Car {
    int speed;      // default = 0
    String brand;   // default = null
    boolean on;     // default = false
}
</code></pre>

                        <h3>Explanation</h3>
                        <p>
                            Here, Java silently adds:
                        </p>

                        <pre><code class="language-java">
Car() {
    super(); // call to Object class
}
</code></pre>

                        <p>
                            This constructor does nothing except calling parent class constructor.
                        </p>

                        <h4>Real World Example</h4>
                        <p>
                            It's like building a car from the factory with:
                            <strong>no custom features</strong>.
                            Everything is set to its default state:
                            speed = 0, engine OFF, no color set.
                        </p>

                        <hr>

                        <!-- ========================================================= -->
                        <!-- =============== 2. NO-ARG CONSTRUCTOR =================== -->
                        <!-- ========================================================= -->

                        <h3>2. No-Argument (No-Arg) Constructor</h3>

                        <p>
                            This is a constructor that accepts <strong>no parameters</strong> and sets object values
                            manually.
                        </p>

                        <pre><code class="language-java">
class Car {
    String brand;
    int speed;

    Car() {
        brand = "Unknown";
        speed = 0;
        System.out.println("No-arg constructor executed");
    }
}
</code></pre>

                        <h3>Explanation</h3>
                        <p>
                            When you create:
                        </p>

                        <pre><code class="language-java">
Car c = new Car();
</code></pre>

                        <p>
                            It sets initial values like:
                        <ul>
                            <li><strong>brand</strong> = "Unknown"</li>
                            <li><strong>speed</strong> = 0</li>
                        </ul>
                        </p>

                        <h4>Real World Example</h4>
                        <p>
                            You buy a car without selecting any features →
                            Factory gives you a default model with standard features.
                        </p>

                        <hr>

                        <!-- ========================================================= -->
                        <!-- =============== 3. PARAMETERIZED CONSTRUCTOR ============ -->
                        <!-- ========================================================= -->

                        <h3>3. Parameterized Constructor</h3>

                        <p>
                            Used when you want to initialize objects with <strong>specific values</strong>.
                        </p>

                        <pre><code class="language-java">
class Car {
    String brand;
    int speed;

    Car(String brand, int speed) {
        this.brand = brand; // the brand variable of this object
        this.speed = speed;
    }
}
</code></pre>

                        <h3>Explanation</h3>
                        <p>
                            Here:
                        </p>

                        <pre><code class="language-java">
Car c = new Car("BMW", 180);
</code></pre>

                        <p>
                            It immediately creates a BMW car with 180 speed.
                        </p>

                        <h4>Real World Example</h4>
                        <p>
                            You place a custom order for a car:
                        <ul>
                            <li>You choose the brand</li>
                            <li>You choose the engine/speed</li>
                        </ul>
                        Factory manufactures exactly what you want.
                        </p>

                        <hr>

                        <!-- ========================================================= -->
                        <!-- ================== 4. COPY CONSTRUCTOR ================== -->
                        <!-- ========================================================= -->

                        <h3>4. Copy Constructor</h3>

                        <p>
                            A user-defined constructor that copies one object into another.
                            Java DOES NOT provide it automatically.
                        </p>

                        <pre><code class="language-java">
class Car {
    String brand;
    int speed;

    Car(Car c) {        // copy constructor
        this.brand = c.brand;
        this.speed = c.speed;
    }
}
</code></pre>

                        <h3>Explanation</h3>
                        <p>
                            You can write:
                        </p>

                        <pre><code class="language-java">
Car c1 = new Car("Tesla", 200);
Car c2 = new Car(c1); // copying object
</code></pre>

                        <p>
                            Now <strong>c2</strong> has the same values as <strong>c1</strong>.
                        </p>

                        <h4>Real World Example</h4>
                        <p>
                            You ask the factory to create “the same car as my friend’s car”.
                            The factory clones the exact configuration.
                        </p>

                        <hr>

                        <!-- ========================================================= -->
                        <!-- =============== 5. PRIVATE CONSTRUCTOR ================== -->
                        <!-- ========================================================= -->

                        <h3>5. Private Constructor</h3>

                        <p>
                            Used mostly for <strong>Singleton Pattern</strong> or factory classes.
                            It prevents others from creating objects.
                        </p>

                        <pre><code class="language-java">
class DatabaseConnection {
    private DatabaseConnection() {
        System.out.println("Database connected");
    }

    private static DatabaseConnection instance = new DatabaseConnection();

    public static DatabaseConnection getInstance() {
        return instance;
    }
}
</code></pre>

                        <h3>Real World Use Case</h3>
                        <p>
                            A Database should have <strong>only one connection</strong>.
                            Private constructor ensures no one creates multiple objects.
                        </p>

                        <hr>

                        <!-- ========================================================= -->
                        <!-- =============== 6. PROTECTED CONSTRUCTOR ================ -->
                        <!-- ========================================================= -->

                        <h3>6. Protected Constructor</h3>

                        <p>
                            Accessible within:
                        <ul>
                            <li>same package</li>
                            <li>child classes (even if in different packages)</li>
                        </ul>
                        </p>

                        <pre><code class="language-java">
class Vehicle {
    protected Vehicle() {
        System.out.println("Protected Vehicle Constructor");
    }
}
</code></pre>

                        <h4>Real World Example</h4>
                        <p>
                            You can only build this type of vehicle if:
                        <ul>
                            <li>You are part of the same company (package)</li>
                            <li>Or you own a child company (subclass)</li>
                        </ul>
                        </p>

                        <hr>

                        <!-- ========================================================= -->
                        <!-- ================== 7. CONSTRUCTOR OVERLOADING ========== -->
                        <!-- ========================================================= -->

                        <h3>7. Constructor Overloading</h3>

                        <p>
                            You can create multiple constructors with different sets of parameters.
                        </p>

                        <pre><code class="language-java">
class Car {
    Car() { System.out.println("Default car"); }
    Car(int speed) { this.speed = speed; }
    Car(String brand, int speed) { this.brand = brand; this.speed = speed; }
}
</code></pre>

                        <h3>Real World Example</h3>
                        <p>
                            Different ways to buy a car:
                        <ul>
                            <li>Buy base model</li>
                            <li>Select speed only</li>
                            <li>Select brand and speed</li>
                        </ul>
                        </p>

                        <hr>

                        <!-- ========================================================= -->
                        <!-- ================== 8. CONSTRUCTOR CHAINING ============= -->
                        <!-- ========================================================= -->

                        <h3>8. Constructor Chaining</h3>

                        <p>
                            Calling one constructor from another using <strong>this()</strong> or
                            <strong>super()</strong>.
                        </p>

                        <pre><code class="language-java">
class Car {
    String brand;
    int speed;

    Car() {
        this("Unknown", 0); // calling another constructor
    }

    Car(String brand, int speed) {
        this.brand = brand;
        this.speed = speed;
    }
}
</code></pre>

                        <h3>Real World Example</h3>
                        <p>
                            A base car model always uses a more detailed manufacturing process internally.
                        </p>

                        <h4>Using <code>super()</code> in Inheritance</h4>

                        <pre><code class="language-java">
class Vehicle {
    Vehicle() {
        System.out.println("Vehicle Constructor");
    }
}

class Car extends Vehicle {
    Car() {
        super();
        System.out.println("Car Constructor");
    }
}
</code></pre>

                        <p>
                            Output:
                        </p>

                        <pre><code>
Vehicle Constructor
Car Constructor
</code></pre>

                        <hr>

                        <h2>Complete Real-World Constructor Example</h2>

                        <pre><code class="language-java">
class Car {

    String brand;
    int speed;
    String fuelType;

    // No-argument constructor
    Car() {
        this("Unknown", 0, "Petrol");
        System.out.println("Default car created.");
    }

    // Parameterized constructor
    Car(String brand, int speed, String fuelType) {
        this.brand = brand;
        this.speed = speed;
        this.fuelType = fuelType;
    }

    // Copy constructor
    Car(Car other) {
        this.brand = other.brand;
        this.speed = other.speed;
        this.fuelType = other.fuelType;
    }

    void show() {
        System.out.println("Brand: " + brand);
        System.out.println("Speed: " + speed);
        System.out.println("Fuel: " + fuelType);
    }
}

public class Main {
    public static void main(String[] args) {

        Car c1 = new Car();  // no-arg
        c1.show();

        Car c2 = new Car("Tesla", 200, "Electric"); // parameterized
        c2.show();

        Car c3 = new Car(c2); // copy constructor
        c3.show();
    }
}
</code></pre>

                        <p>
                            This demonstrates all constructor types in a real-world scenario.
                        </p>

                        <hr>

                        <h2>Conclusion</h2>
                        <p>
                            Constructors are the backbone of object initialization in Java.
                            They:
                        <ul>
                            <li>Provide meaningful starting values</li>
                            <li>Reduce code duplication</li>
                            <li>Offer flexibility through overloading</li>
                            <li>Ensure safe object creation using private/protected constructors</li>
                            <li>Support inheritance with <code>super()</code></li>
                        </ul>
                        Understanding constructors is essential to master Object-Oriented Programming.
                        </p>


                    </section>

                    <section class="docs-section" id="item-2-15">
                        <h1 class="docs-heading">
                            Class 7 - Recording
                        </h1>
                        <a href="#" target="_blank" class="full-width-btn">
                            ▶ Watch Video
                        </a>

                    </section>

                    <!-- Inheritance -->
                    <section class="docs-section" id="item-2-16">
                        <h2>Inheritance in Java</h2>
                        <p>Inheritance allows a subclass to acquire the properties and behaviors of a superclass. It
                            promotes code reusability and method overriding.</p>

                        <h3>Example:</h3>
                        <pre>
<code>
class Animal {
    void sound() {
        System.out.println("Animals make sounds");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound(); // Output: Dog barks
    }
}
</code>
        </pre>

                        <h3>Important Points:</h3>
                        <ul>
                            <li>Java does not support multiple inheritance with classes.</li>
                            <li>All classes inherit from the Object class.</li>
                            <li>Use <code>super</code> to access parent methods or constructors.</li>
                        </ul>

                        <h3>Related Exceptions:</h3>
                        <pre>
<code>
// ClassCastException example
Animal a = new Animal();
Dog d = (Dog) a; // Throws ClassCastException
</code>
        </pre>
                    </section>

                    <!-- Polymorphism -->
                    <section class="docs-section" id="item-2-17">
                        <h2>Polymorphism in Java</h2>
                        <p>Polymorphism means one interface, many implementations. It allows methods to behave
                            differently based on the object.</p>

                        <h3>1. Compile-time Polymorphism (Method Overloading)</h3>
                        <pre>
<code>
class MathOps {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
}
</code>
        </pre>

                        <h3>2. Runtime Polymorphism (Method Overriding)</h3>
                        <pre>
<code>
class Bird {
    void fly() {
        System.out.println("Bird is flying");
    }
}

class Eagle extends Bird {
    void fly() {
        System.out.println("Eagle flies high");
    }
}

public class Test {
    public static void main(String[] args) {
        Bird b = new Eagle();
        b.fly(); // Output: Eagle flies high
    }
}
</code>
        </pre>

                        <h3>Important Points:</h3>
                        <ul>
                            <li>Method overloading is resolved at compile-time.</li>
                            <li>Method overriding is resolved at runtime.</li>
                            <li>Overridden methods must have the same signature.</li>
                            <li>Return type can be covariant (subtype allowed).</li>
                        </ul>

                        <h3>Related Exceptions:</h3>
                        <pre>
<code>
// Wrong downcasting -> ClassCastException
Bird b = new Bird();
Eagle e = (Eagle) b; // Throws ClassCastException
</code>
        </pre>
                    </section>

                    <!-- Encapsulation -->
                    <section class="docs-section" id="item-2-18">
                        <h2>Encapsulation in Java</h2>
                        <p>Encapsulation wraps data (variables) and methods within a class and protects them from
                            unauthorized access using private access modifiers.</p>

                        <h3>Example:</h3>
                        <pre>
<code>
class Student {
    private String name;
    private int age;

    public String getName() { return name; }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() { return age; }

    public void setAge(int age) {
        if (age > 0) {
            this.age = age;
        } else {
            System.out.println("Invalid age");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Student s = new Student();
        s.setName("John");
        s.setAge(20);

        System.out.println(s.getName());
        System.out.println(s.getAge());
    }
}
</code>
        </pre>

                        <h3>Important Points:</h3>
                        <ul>
                            <li>Use private variables and public getters/setters.</li>
                            <li>Encapsulation protects data and enables validation.</li>
                            <li>Improves maintainability and flexibility.</li>
                        </ul>

                        <h3>Related Exceptions:</h3>
                        <pre>
<code>
// Custom exception in setter
public void setAge(int age) {
    if (age <= 0) {
        throw new IllegalArgumentException("Age must be positive");
    }
    this.age = age;
}
</code>
        </pre>
                    </section>

                    <!--//section-->
                </article>
            </div>
        </div>


    </div>





    <!-- Javascript -->
    <script src="../assets/plugins/popper.min.js"></script>
    <script src="../assets/plugins/bootstrap/js/bootstrap.min.js"></script>

    <!-- Page Specific JS -->
    <script src="../assets/plugins/smoothscroll.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
    <script src="../assets/js/highlight-custom.js"></script>
    <script src="../assets/plugins/simplelightbox/simple-lightbox.min.js"></script>
    <script src="../assets/plugins/gumshoe/gumshoe.polyfills.min.js"></script>
    <script src="../assets/js/docs.js"></script>

</body>

</html>