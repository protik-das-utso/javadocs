<!DOCTYPE html>
<html lang="en">

<head>
    <title>
        Java Documentation - Protik The DEV
    </title>

    <!-- Meta -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Java Documentation For Software Developers" />
    <meta name="author" content="Protik The DEV" />
    <link rel="shortcut icon" href="../favicon.png" />

    <!-- Google Font -->
    <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet" />

    <!-- FontAwesome JS-->
    <script defer src="../assets/fontawesome/js/all.min.js"></script>

    <!-- Plugins CSS -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.2/styles/atom-one-dark.min.css" />
    <link rel="stylesheet" href="../assets/plugins/simplelightbox/simple-lightbox.min.css" />

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="../assets/css/theme.css" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-TCN8REREGW"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-TCN8REREGW');
    </script>
</head>

<body>

    <header class="header fixed-top">
        <div class="branding docs-branding">
            <div class="container-fluid position-relative py-2">
                <div class="docs-logo-wrapper">
                    <button id="docs-sidebar-toggler" class="docs-sidebar-toggler docs-sidebar-visible me-2 d-xl-none"
                        type="button">
                        <span></span>
                        <span></span>
                        <span></span>
                    </button>
                    <div class="site-logo">
                        <a class="navbar-brand" href="index.html"><img class="logo-icon me-2" src="../favicon.png"
                                alt="logo" width="50px" /><span class="logo-text">Java <span
                                    class="text-alt">Documentation</span></span></a>
                    </div>
                </div>
                <!--//docs-logo-wrapper-->
                <div class="docs-top-utilities d-flex justify-content-end align-items-center">
                    <!-- Include Lunr.js -->
                    <script src="https://unpkg.com/lunr/lunr.js"></script>
                    <!-- Your search form -->
                    <div class="top-search-box d-none d-lg-flex">
                        <form class="search-form" id="searchForm">
                            <input type="text" placeholder="Search the docs..." name="search"
                                class="form-control search-input" id="searchInput" />
                            <button type="submit" class="btn search-btn" value="Search">
                                <i class="fas fa-search"></i>
                            </button>
                        </form>
                    </div>

                    <ul class="social-list list-inline mx-md-3 mx-lg-5 mb-0 d-none d-lg-flex">
                        <li class="list-inline-item">
                            <a href="https://github.com/protik-das-utso" target="_blank"><i
                                    class="fa-brands fa-github fa-fw"></i></a>
                        </li>
                        <li class="list-inline-item">
                            <a href="https://t.me/protikthedev" target="_blank"><i
                                    class="fa-brands fa-telegram fa-fw"></i></a>
                        </li>
                        <li class="list-inline-item">
                            <a href="http://facebook.com/protikthedeveloper" target="_blank"><i
                                    class="fa-brands fa-facebook fa-fw"></i></a>
                        </li>
                        <li class="list-inline-item">
                            <a href="https://www.youtube.com/@protikthedev" target="_blank"><i
                                    class="fa-brands fa-youtube fa-fw"></i></a>
                        </li>
                    </ul>
                    <!--//social-list-->
                    <a href="https://t.me/protikthedev" target="_blank" class="btn btn-primary d-none d-lg-flex">Join
                        Telegram</a>
                </div>
                <!--//docs-top-utilities-->
            </div>
            <!--//container-->
        </div>
        <!--//branding-->
    </header>
    <!--//header-->

    <div class="docs-wrapper">

        <div id="docs-sidebar" class="docs-sidebar">
            <div class="top-search-box d-lg-none p-3">
                <form class="search-form">
                    <input type="text" placeholder="Search the docs..." name="search"
                        class="form-control search-input" />
                    <button type="submit" class="btn search-btn" value="Search">
                        <i class="fas fa-search"></i>
                    </button>
                </form>
            </div>
            <nav id="docs-nav" class="docs-nav navbar">
                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title">
                        <a class="nav-link scrollto active" href="#week-1"><span class="theme-icon-holder me-2"><i
                                    class="fas fa-map-signs"></i></span>Week 1</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#week-1">Course Introduction</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-1" b style="color: red;">Class 1 - Recording</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-2">JDK & IDE Setup</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-3">Java Structure</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-4" b style="color: red;">Class 2 - Recording</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-5">Data Types</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-6">Variables</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-7" b style="color: red;">Class 3 - Recording</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-8">Control Flow (if, loop, switch)</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link scrollto" href="#item-1-9">Debugging Basics</a>
                    </li>
                    <li class="nav-item section-title mt-3">
                        <a class="nav-link" href="../week-2/"><span class="theme-icon-holder me-2"><i
                                    class="fas fa-arrow-down"></i></span>Week 2</a>
                    </li>
                    
                </ul>
            </nav>
            <!--//docs-nav-->
        </div>


        <!--//docs-sidebar-->
        <div class="docs-content">
            <div class="container">
                <article class="docs-article" id="week-1">
                    <header class="docs-header">
                        <h1 class="docs-heading">
                            Course Introduction
                        </h1>
                        <!-- Search Results -->
                        <div id="searchResults"></div>
                        <script>
                            document.addEventListener('DOMContentLoaded', function () {
                                if (typeof lunr === 'undefined') {
                                    console.error('Lunr.js not found. Load https://unpkg.com/lunr/lunr.js before this script.');
                                    return;
                                }

                                // ----------------------------
                                // 1) Utilities
                                // ----------------------------
                                const scope = document.querySelector('.docs-content') || document;
                                const isHeading = n => n && /^H[1-6]$/.test(n.tagName);
                                const levelBoost = { H1: 12, H2: 8, H3: 5, H4: 3, H5: 2 };

                                // Normalize for case/diacritics to keep searching standard & user-friendly
                                const normalize = s =>
                                    (s || '')
                                        .normalize('NFKD')
                                        .replace(/[\u0300-\u036f]/g, '')   // strip accents
                                        .replace(/\s+/g, ' ')
                                        .trim();

                                function snippetFrom(el, limit = 260) {
                                    let txt = '';
                                    let n = el.nextElementSibling;
                                    while (n && !isHeading(n)) {
                                        if (n.matches('p, ul, ol, pre, code, table, blockquote')) {
                                            txt += ' ' + normalize(n.innerText);
                                            if (txt.length >= limit) break;
                                        }
                                        n = n.nextElementSibling;
                                    }
                                    return txt.trim().slice(0, limit);
                                }

                                // ----------------------------
                                // 2) Collect documents (H1..H5) with clean breadcrumbs
                                // ----------------------------
                                const docs = [];
                                let h1 = '', h2 = '', h3 = '';
                                const nodes = scope.querySelectorAll('h1.docs-heading, h2, h3');

                                nodes.forEach((el, i) => {
                                    if (el.closest('#docs-sidebar')) return;              // ignore sidebar
                                    const tag = el.tagName;                               // "H1".."H5"
                                    const level = parseInt(tag[1], 10);                   // 1..5

                                    if (tag === 'H1') { h1 = normalize(el.textContent); h2 = h3 = ''; }
                                    if (tag === 'H2') { h2 = normalize(el.textContent); h3 = ''; }
                                    if (tag === 'H3') { h3 = normalize(el.textContent); }

                                    if (!el.id) el.id = 'heading-' + i;

                                    const title = normalize(el.textContent);
                                    // Breadcrumb without duplicates; H1 shows only itself
                                    let ancestors = [h1, h2, h3].filter(Boolean).filter(a => a !== title);
                                    const breadcrumb = (level === 1) ? title : [...ancestors, title].join(' ‚Ä∫ ');

                                    docs.push({
                                        id: el.id,
                                        level,
                                        title,
                                        breadcrumb,
                                        content: snippetFrom(el),
                                        url: '#' + el.id,
                                        boost: levelBoost[tag] || 1
                                    });
                                });

                                // ----------------------------
                                // 3) Build index (title > breadcrumb > content)
                                // ----------------------------
                                const idx = lunr(function () {
                                    this.ref('id');
                                    this.field('title', { boost: 9 });
                                    this.field('breadcrumb', { boost: 6 });
                                    this.field('content', { boost: 1 });

                                    // Pipeline already lowercases / stems; we pre-normalize too
                                    docs.forEach(d => {
                                        this.add({
                                            id: d.id,
                                            title: d.title,
                                            breadcrumb: d.breadcrumb,
                                            content: d.content
                                        }, { boost: d.boost });
                                    });
                                });

                                // ----------------------------
                                // 4) Query parsing (phrase, boolean, prefix, fuzzy)
                                // ----------------------------
                                // Supports:
                                //   - Phrases in quotes: "bytecode verifier"
                                //   - Words: java, structure
                                //   - Prefix with *: jav*
                                //   - Simple OR with ' OR ' (default is AND across terms)
                                function parseQuery(qRaw) {
                                    const q = normalize(qRaw).toLowerCase();
                                    if (!q) return { groups: [] };

                                    // Split by OR (optional). Each group is ANDed internally; groups are ORed
                                    const groups = q.split(/\s+or\s+/i).map(g => g.trim()).filter(Boolean);

                                    return {
                                        groups: groups.map(group => {
                                            // Extract phrases in quotes
                                            const phrases = [];
                                            let rest = group.replace(/"([^"]+)"/g, (_, p1) => { phrases.push(p1.trim()); return ' '; }).trim();

                                            // Remaining terms (keep * for explicit prefix)
                                            const terms = rest.split(/\s+/).filter(Boolean);

                                            return { phrases, terms };
                                        })
                                    };
                                }

                                function buildQuery(qRaw) {
                                    const parsed = parseQuery(qRaw);

                                    return function (query) {
                                        if (!parsed.groups.length) return;

                                        // For each OR group
                                        parsed.groups.forEach((g, gi) => {
                                            // Phrases: require one of title/breadcrumb/content (pipeline + high boost)
                                            g.phrases.forEach(ph => {
                                                // Exact phrase in title/breadcrumb gets top boost
                                                query.clause({
                                                    term: ph,
                                                    fields: ['title', 'breadcrumb'],
                                                    presence: lunr.Query.presence.REQUIRED,
                                                    usePipeline: true,
                                                    boost: 10
                                                });
                                                // Also allow in content (optional, lower boost)
                                                query.clause({
                                                    term: ph,
                                                    fields: ['content'],
                                                    presence: lunr.Query.presence.OPTIONAL,
                                                    usePipeline: true,
                                                    boost: 3
                                                });
                                            });

                                            // Terms: AND across the group, with prefix/fuzzy + pipeline
                                            g.terms.forEach(t => {
                                                const isPrefix = /\*$/.test(t);
                                                const term = isPrefix ? t.replace(/\*+$/, '') : t;
                                                const isLong = term.length >= 5;

                                                // One clause across multiple fields = OR between fields, REQUIRED overall
                                                query.clause({
                                                    term: term,
                                                    fields: ['title', 'breadcrumb', 'content'],
                                                    presence: lunr.Query.presence.REQUIRED,
                                                    usePipeline: true,
                                                    wildcard: isPrefix ? lunr.Query.wildcard.TRAILING : lunr.Query.wildcard.NONE,
                                                    editDistance: isLong ? 2 : 1,   // tolerate minor typos
                                                    boost: 5
                                                });
                                            });
                                        });
                                    };
                                }

                                // ----------------------------
                                // 5) Rendering (H1 first, then others; highlight; small UX polish)
                                // ----------------------------
                                const desktopForm = document.getElementById('searchForm');
                                const desktopInput = document.getElementById('searchInput');
                                const mobileInput = document.querySelector('#docs-sidebar .search-input');
                                const inputs = [desktopInput, mobileInput].filter(Boolean);

                                let resultBox = document.getElementById('searchResults');
                                if (!resultBox) {
                                    resultBox = document.createElement('div');
                                    resultBox.id = 'searchResults';
                                    const heading = scope.querySelector('.docs-heading');
                                    (heading ? heading.parentElement : document.body).appendChild(resultBox);
                                }

                                function esc(s) { return s.replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c])); }
                                function hi(text, terms) {
                                    if (!text) return '';
                                    const pattern = terms.length ? terms.map(t => t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|') : null;
                                    return pattern ? esc(text).replace(new RegExp(`\\b(${pattern})`, 'gi'), '<mark>$1</mark>') : esc(text);
                                }
                                function makeSnippet(content, terms, len = 200) {
                                    if (!content) return '';
                                    const lower = content.toLowerCase();
                                    let idx = 0;
                                    for (const t of terms) {
                                        const i = lower.indexOf(t);
                                        if (i !== -1) { idx = i; break; }
                                    }
                                    const start = Math.max(0, idx - 40);
                                    const slice = content.slice(start, start + len);
                                    return (start > 0 ? '‚Ä¶ ' : '') + slice + (start + len < content.length ? ' ‚Ä¶' : '');
                                }

                                function render(results, qRaw) {
                                    const q = normalize(qRaw).toLowerCase();
                                    const terms = q.replace(/"([^"]+)"/g, '$1').split(/\s+|or/ig).map(s => s.trim()).filter(Boolean);

                                    if (!results.length) { resultBox.innerHTML = '<p>No results found.</p>'; return; }

                                    // Map to docs, unique, then split H1 vs others
                                    const seen = new Set();
                                    const mapped = results.map(r => docs.find(d => d.id === r.ref)).filter(Boolean)
                                        .filter(d => (seen.has(d.id) ? false : seen.add(d.id)));

                                    const h1s = mapped.filter(d => d.level === 1);
                                    const rest = mapped.filter(d => d.level !== 1);

                                    // If any H1 match, show H1 group first, then others
                                    const groups = h1s.length ? [{ title: 'Top-level sections', items: h1s },
                                    { title: 'More results', items: rest }] :
                                        [{ title: 'Results', items: rest }];

                                    const html = groups.map(g => {
                                        if (!g.items.length) return '';
                                        const itemsHtml = g.items.map(d => {
                                            const snip = makeSnippet(d.content || d.title, terms);
                                            return `
          <li style="margin:0 0 10px;">
            <a href="${d.url}" class="fw-bold">${hi(d.breadcrumb, terms)}</a><br>
            <small style="color:#666;">${hi(snip, terms)}</small>
          </li>`;
                                        }).join('');
                                        return `
        <div style="margin:8px 0 12px;">
          <div style="font-weight:700;margin-bottom:6px;">${esc(g.title)}</div>
          <ul style="list-style:none;padding-left:0;margin:0;">
            ${itemsHtml}
          </ul>
        </div>`;
                                    }).join('');

                                    resultBox.innerHTML = html;
                                }

                                function runSearch(qRaw) {
                                    if (!qRaw || !qRaw.trim()) { resultBox.innerHTML = ''; return; }
                                    try {
                                        const res = idx.query(buildQuery(qRaw)).sort((a, b) => b.score - a.score);
                                        render(res, qRaw);
                                    } catch (e) {
                                        // Simple substring fallback (still normalized)
                                        const q = normalize(qRaw).toLowerCase();
                                        const res = docs
                                            .filter(d => (d.title + ' ' + d.breadcrumb + ' ' + d.content).toLowerCase().includes(q))
                                            .map(d => ({ ref: d.id, score: 0.0001 }));
                                        render(res, qRaw);
                                    }
                                }

                                // Submit + live search (debounced)
                                const desktopFormEl = document.getElementById('searchForm');
                                if (desktopFormEl) {
                                    desktopFormEl.addEventListener('submit', e => {
                                        e.preventDefault();
                                        runSearch((desktopInput?.value || '').trim());
                                    });
                                }
                                let deb;
                                inputs.forEach(inp => inp && inp.addEventListener('input', () => {
                                    clearTimeout(deb);
                                    deb = setTimeout(() => runSearch(inp.value), 150);
                                }));

                                console.log('Indexed sections:', docs.length);
                            });
                        </script>


                        <section class="docs-intro">
                            <p>
                                Welcome to the Basic Java to Advanced Spring Boot Backend
                                Development Course ‚Äî a six-month journey designed to take you
                                from the fundamentals of Java programming to building
                                full-stack backend applications.
                            </p>

                            <p>
                                This course begins with Core Java Essentials, covering syntax,
                                OOP, and debugging skills, and later expands into JDBC, Spring
                                Boot, REST APIs, Security, and Microservices
                            </p>
                        </section>
                        <!--//docs-intro-->

                        <h2>Mentor:</h2>
                        <p>
                            <a class="theme-link" href="https://facebook.com/protikthedev" target="_blank">PROTIK DAS
                                UTSO</a>
                        </p>
                        <i>Dept. of CSE, Daffodil International University</i>
                        <div class="alert alert-success" role="alert">
                            ‚ÄúI don‚Äôt just write code ‚Äî I build possibilities.‚Äù
                        </div>

                        <h2>Learning Goals:</h2>
                        <ul>
                            <li>Understand the core concepts of Java programming.</li>
                            <li>
                                Set up the development environment for efficient coding.
                            </li>
                            <li>Learn how to structure, compile, and run Java programs.</li>
                            <li>
                                Build a strong foundation for advanced backend technologies
                                such as Spring Boot.
                            </li>
                        </ul>
                        <h2>Course Structure</h2>
                        <ul>
                            <li><strong>Duration</strong> ‚Äî 24 weeks | 6 months</li>
                            <li>
                                <strong>Schedule</strong> ‚Äî 3 classes per week √ó 1.5 hours
                                each
                            </li>
                            <li>
                                <strong>Total</strong> ‚Äî ‚âà 108 hours + 12 hours
                                problem-solving sessions
                            </li>
                        </ul>
                        <h2>Outcome:</h2>
                        <p>
                            After this introduction, you‚Äôll clearly understand what Java is,
                            why it‚Äôs relevant, and how this course will progressively build
                            your development skills.
                        </p>

                        <div class="alert alert-secondary" role="alert"
                            style="display: flex; justify-content: space-between; align-items: center;">
                            <p style="align-items: center; margin-top: 15px;">üìö Course Outline</p>
                            <button class="btn btn-outline-secondary btn-sm"><a href="https://t.me/protikthedev/10"
                                    target="_blank" style="font-size: 20px;">Download</a></button>
                        </div>
                    </header>
                    <!-- JDK & IDE Setup -->
                    <section class="docs-section" id="item-1-1">
                        <h1 class="docs-heading">
                            Class 1 - Recording
                        </h1>
                        <a href="https://www.youtube.com/watch?v=hPF2XUoWNn8" target="_blank"
                            class="full-width-btn">
                            ‚ñ∂ Watch Video
                        </a>

                    </section>
                    <!--//section-->

                    <!-- JDK & IDE Setup -->
                    <section class="docs-section" id="item-1-2">
                        <h1 class="docs-heading">
                            JDK & IDE Setup
                        </h1>
                        <h2>‚òï 1. JDK (Java Development Kit)</h2>
                        <p>Used to write and compile Java programs.</p>
                        <p><strong>Contains:</strong> JRE + compiler (<code>javac</code>) + tools.</p>
                        <p><strong>üí° Example:</strong> When you type:</p>
                        <pre><code>javac Hello.java</code></pre>
                        <p>you‚Äôre using the JDK to compile your code.</p>

                        <h2>‚öôÔ∏è 2. JRE (Java Runtime Environment)</h2>
                        <p>Used to run Java programs.</p>
                        <p><strong>Contains:</strong> JVM + libraries needed to execute code.</p>
                        <p><strong>üí° Example:</strong> When you run:</p>
                        <pre><code>java Hello</code></pre>
                        <p>the JRE runs your compiled program.</p>

                        <h2>üíª 3. JVM (Java Virtual Machine)</h2>
                        <p>The engine that executes the compiled Java bytecode.</p>
                        <p>It makes Java platform-independent ‚Äî the same code can run on Windows, Mac, or Linux.</p>
                        <p><strong>üí° Example:</strong> The <code>.class</code> file created by the JDK is executed by
                            the JVM inside the JRE.</p>

                        <h2>üß© In short</h2>
                        <ul>
                            <li><strong>JDK</strong> = JRE + Development Tools</li>
                            <li><strong>JRE</strong> = JVM + Libraries</li>
                        </ul>

                        <h2>üîÅ Example flow</h2>
                        <ol>
                            <li>You write a program ‚Üí <code>Hello.java</code></li>
                            <li>JDK compiles it ‚Üí creates <code>Hello.class</code> (bytecode)</li>
                            <li>JRE runs it ‚Üí JVM executes bytecode line by line</li>
                        </ol>

                        <h2>Step-by-Step Installation</h2>
                        <ol>
                            <li>Download the latest JDK from <a
                                    href="https://www.oracle.com/apac/java/technologies/downloads/"
                                    target="_blank">Oracle</a> or <a href="https://openjdk.org/"
                                    target="_blank">OpenJDK</a>.</li>
                            <li>Install and follow the wizard for your OS.</li>
                        </ol>

                        <h2>Set Environment Variables</h2>
                        <p><strong>Windows:</strong> Add <code>JAVA_HOME</code> to System Variables ‚Üí point to JDK
                            folder.</p>
                        <p><strong>Mac/Linux:</strong> Add to <code>.bashrc</code> or <code>.zshrc</code>:</p>
                        <pre><code>export JAVA_HOME=/usr/lib/jvm/java-17-openjdk
export PATH=$JAVA_HOME/bin:$PATH</code></pre>

                        <h2>Verify Installation</h2>
                        <pre><code>java -version
javac -version</code></pre>
                        <p>Output should display the installed version.</p>

                        <h2>Installing an IDE</h2>
                        <p>An IDE (Integrated Development Environment) helps you code faster and debug easier.</p>
                        <ul>
                            <li><strong>IntelliJ IDEA:</strong> Smart and modern, ideal for professionals.</li>
                            <li><strong>Eclipse:</strong> Stable and used widely in enterprises.</li>
                            <li><strong>VS Code:</strong> Lightweight with Java extensions.</li>
                        </ul>

                        <h2>IDE Setup Checklist</h2>
                        <ol>
                            <li>Open the IDE ‚Üí Select <strong>New Project</strong> ‚Üí <strong>Java Project</strong>.</li>
                            <li>Set the project SDK to your installed JDK.</li>
                            <li>Create a class file and write:</li>
                        </ol>

                        <pre><code>public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, Java!");
    }
}</code></pre>

                        <p>Click <strong>Run</strong> ‚Äî your first Java program is live!</p>

                        <h2>Troubleshooting Tips</h2>
                        <ul>
                            <li><strong>‚Äújavac not found‚Äù</strong> ‚Üí Check PATH variable.</li>
                            <li><strong>‚ÄúCannot find symbol‚Äù</strong> ‚Üí Ensure file and class names match.</li>
                            <li><strong>IDE red underlines</strong> ‚Üí Set the correct JDK path in project settings.</li>
                        </ul>

                    </section>
                    <!--//section-->

                    <!-- Java Structure -->
                    <section class="docs-section" id="item-1-3">
                        <h1 class="docs-heading">
                            Java Structure
                        </h1>
                        <article>

                            <p>A quick, practical guide to how a basic Java program is organized‚Äîclasses, methods,
                                the <code>main</code> entry point, packages, and more.</p>

                            <section id="hello-world">
                                <h2>Minimal Program (‚ÄúHello, Java‚Äù)</h2>
                                <pre><code class="language-java">public class Main {
    // Program entry point
    public static void main(String[] args) {
        System.out.println("Hello, Java!");
    }
}</code></pre>
                                <ul>
                                    <li><strong>Class name:</strong> <code>Main</code> (must match the file name
                                        <code>Main.java</code>).
                                    </li>
                                    <li><strong>Entry point:</strong>
                                        <code>public static void main(String[] args)</code> ‚Äî where execution begins.
                                    </li>
                                    <li><strong>Output:</strong> <code>System.out.println(...)</code> writes to the
                                        console.</li>
                                </ul>
                            </section>

                            <section id="file-class">
                                <h2>Files, Classes, and Bytecode</h2>
                                <ol>
                                    <li>Write code in a file named after the <em>public</em> class (e.g.,
                                        <code>Main.java</code>).
                                    </li>
                                    <li>Compile: <code>javac Main.java</code> ‚Üí generates <code>Main.class</code>
                                        (bytecode).</li>
                                    <li>Run: <code>java Main</code> ‚Üí executes the bytecode on the JVM.</li>
                                </ol>
                                <p><em>Note:</em> A file can contain multiple classes, but at most one
                                    <code>public</code> class, and its name must match the file.
                                </p>
                                <br>
                            </section>

                            <section id="anatomy">
                                <h2>Program Anatomy</h2>
                                <div class="table-responsive my-4">
                                    <table class="table table-bordered">
                                        <thead>
                                            <tr>
                                                <th>Component</th>
                                                <th>Description</th>
                                                <th>Example</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td><strong>Package</strong></td>
                                                <td>Defines a namespace to organize related classes.</td>
                                                <td><code>package com.example.app;</code></td>
                                            </tr>
                                            <tr>
                                                <td><strong>Import Statement</strong></td>
                                                <td>Includes external classes or packages for use in your program.</td>
                                                <td><code>import java.util.Scanner;</code></td>
                                            </tr>
                                            <tr>
                                                <td><strong>Class Declaration</strong></td>
                                                <td>The blueprint that encapsulates data (fields) and behavior
                                                    (methods).</td>
                                                <td><code>public class Main { ... }</code></td>
                                            </tr>
                                            <tr>
                                                <td><strong>Main Method</strong></td>
                                                <td>The entry point of any Java program‚Äîexecution begins here.</td>
                                                <td><code>public static void main(String[] args) { ... }</code></td>
                                            </tr>
                                            <tr>
                                                <td><strong>Statements</strong></td>
                                                <td>Instructions executed by the JVM; each must end with a semicolon
                                                    (<code>;</code>).</td>
                                                <td><code>System.out.println("Hello, World!");</code></td>
                                            </tr>
                                            <tr>
                                                <td><strong>Comments</strong></td>
                                                <td>Used to describe or explain code without affecting execution.</td>
                                                <td><code>// This is a comment</code></td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </section>

                            <section id="java-execution">
                                <header>
                                    <h2>How Java Code Executes</h2>
                                    <p>This section explains the full journey from a <code>.java</code> source file to a
                                        running program on your machine.</p>
                                </header>

                                <figure style="margin:1rem 0;">
                                    <!-- Replace the src with your hosted image URL -->
                                    <img src="../assets/images/How-Java-Code-Executes.png"
                                        alt="Diagram showing the flow: HelloWorld.java ‚Üí Java Compiler ‚Üí HelloWorld.class ‚Üí JVM ‚Üí Program output"
                                        style="max-width:100%;height:auto;border-radius:8px;">
                                    <figcaption style="font-size:.95rem;color:#555;margin-top:.5rem;">
                                        Java source code is compiled to bytecode (<code>.class</code>) and executed by
                                        the JVM, which produces native machine instructions. Collected from
                                        GeeksforGeeks.
                                    </figcaption>
                                </figure>

                                <ol>
                                    <li>
                                        <h3>Write Source Code (<code>.java</code>)</h3>
                                        <p>You create a file such as <code>HelloWorld.java</code> that contains Java
                                            classes and methods.</p>
                                        <pre><code class="language-java">public class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello, Java!");
  }
}</code></pre>
                                    </li>

                                    <li>
                                        <h3>Compile with <code>javac</code></h3>
                                        <p>The Java compiler checks syntax and type rules, then converts source code
                                            into platform-independent <strong>bytecode</strong> stored in
                                            <code>.class</code> files.
                                        </p>
                                        <pre><code class="language-bash">javac HelloWorld.java   # produces HelloWorld.class</code></pre>
                                    </li>

                                    <li>
                                        <h3>Class Loading</h3>
                                        <p>When you run the program, the <strong>Class Loader</strong> loads required
                                            classes (<code>rt.jar</code>/modules, third-party libs, your classes) into
                                            memory.</p>
                                    </li>

                                    <li>
                                        <h3>Bytecode Verification</h3>
                                        <p>The <strong>Bytecode Verifier</strong> ensures the <code>.class</code> files
                                            are safe and follow JVM constraints (no illegal casts, stack overflows,
                                            etc.).</p>
                                    </li>

                                    <li>
                                        <h3>Execution in the JVM</h3>
                                        <p>The <strong>Execution Engine</strong> of the JVM runs the verified bytecode:
                                        </p>
                                        <ul>
                                            <li><strong>Interpreter</strong> quickly executes bytecode instructions one
                                                by one.</li>
                                            <li><strong>JIT (Just-In-Time) Compiler</strong> detects hot code paths and
                                                compiles them into native machine code for better performance.</li>
                                        </ul>
                                        <p>The JVM manages memory via the <strong>Heap</strong> and
                                            <strong>Stack</strong>, and reclaims unused objects using the
                                            <strong>Garbage Collector</strong>.
                                        </p>
                                    </li>

                                    <li>
                                        <h3>Program Output</h3>
                                        <p>After execution, your program produces output on the console, files, network,
                                            or UI.</p>
                                        <pre><code class="language-bash">java HelloWorld
# ‚Üí Hello, Java!</code></pre>
                                    </li>
                                </ol>

                                <aside
                                    style="background:#f8fafc;border:1px solid #e5e7eb;border-radius:8px;padding:12px;margin-top:16px;">
                                    <h2 style="margin:0 0 .5rem;">CLI Quick Reference</h2>
                                    <pre style="margin:0;"><code class="language-bash"># Compile a single file
javac HelloWorld.java

# Run a class (omit .class)
java HelloWorld

# With packages (run from project root)
javac com/example/app/App.java
java com.example.app.App</code></pre>
                                </aside>


                                <br>
                                <h2>Key Terms</h2>
                                <ul>
                                    <li><strong>JDK</strong>: Tools to compile and develop Java (includes
                                        <code>javac</code> and the JVM).
                                    </li>
                                    <li><strong>JRE</strong>: Environment to run Java apps (JVM + core libraries).
                                    </li>
                                    <li><strong>JVM</strong>: Virtual machine that executes bytecode on any
                                        platform.</li>
                                    <li><strong>Bytecode</strong>: Platform-independent instructions in
                                        <code>.class</code> files.
                                    </li>
                                    <li><strong>JIT</strong>: Compiles hot bytecode paths into native code at
                                        runtime.</li>
                                </ul>

                            </section>


                            <section id="packages-imports">
                                <h2>Packages &amp; Imports</h2>
                                <pre><code class="language-java">package com.acme.app;            // Directory: com/acme/app
import java.util.ArrayList;      // Single class
import java.util.*;              // Wildcard (use sparingly)

public class App {
	public static void main(String[] args) {
		ArrayList<String> items = new ArrayList<>();
		items.add("Java");
		System.out.println(items);
	}
}</code></pre>
                                <ul>
                                    <li>Directory structure mirrors the package path (<code>com/acme/app</code>).</li>
                                    <li>Prefer specific imports over wildcards for clarity.</li>
                                </ul>

                            </section>

                            <section id="access-modifiers">
                                <h2>Access Modifiers &amp; Class Members</h2>
                                <pre><code class="language-java">public class Counter {
	// field (state)
	private int value;

	// constructor
	public Counter(int start) {
		this.value = start;
	}

	// instance method
	public void increment() {
		value++;
	}

	// static method (belongs to the class)
	public static Counter ofZero() {
		return new Counter(0);
	}

	// getter
	public int getValue() {
		return value;
	}

}
</code></pre>
                                <ul>
                                    <li><strong>public</strong>: visible everywhere; <strong>private</strong>: visible
                                        only inside the class.</li>
                                    <li><strong>static</strong> methods/fields belong to the class; instance members
                                        belong to objects.</li>
                                    <li>Use constructors to initialize new objects.</li>
                                </ul>

                            </section>

                            <section id="comments-formatting">
                                <h2>Comments &amp; Formatting</h2>
                                <pre><code class="language-java">/**
 * Calculator utilities.
 */
public class Calc {
    // Single-line comment
    public static int add(int a, int b) {
        return a + b;  // Inline comment (brief!)
    }
}</code></pre>
                                <ul>
                                    <li><strong>Javadoc</strong> (<code>/** ... */</code>) documents APIs and can be
                                        generated into HTML.</li>
                                    <li>Follow consistent indentation and braces style for readability.</li>
                                </ul>
                            </section>

                            <section id="conventions">
                                <h2>Naming &amp; Style Conventions</h2>
                                <ul>
                                    <li><strong>Classes/Interfaces:</strong> PascalCase (e.g.,
                                        <code>OrderService</code>).
                                    </li>
                                    <li><strong>Methods/Variables:</strong> camelCase (e.g., <code>placeOrder</code>,
                                        <code>maxCount</code>).
                                    </li>
                                    <li><strong>Constants:</strong> UPPER_SNAKE_CASE (e.g., <code>MAX_SIZE</code>).</li>
                                    <li><strong>One public class per file</strong>; file name = public class name +
                                        <code>.java</code>.
                                    </li>
                                </ul>
                            </section>

                            <section id="compile-run">
                                <h2>Compile &amp; Run (CLI)</h2>
                                <pre><code class="language-bash"># From the folder containing Main.java
javac Main.java     # compile ‚Üí Main.class
java Main           # run</code></pre>
                                <p>When using packages, compile/run from the project root:</p>
                                <pre><code class="language-bash">javac com/acme/app/App.java
java com.acme.app.App</code></pre>
                            </section>

                            <section id="errors">
                                <h2>Common Structure Errors</h2>
                                <ul>
                                    <li><strong>Class/file mismatch:</strong> Public class <code>App</code> must be in
                                        <code>App.java</code>.
                                    </li>
                                    <li><strong>Missing <code>main</code>:</strong> Applications need an entry point;
                                        libraries don‚Äôt.</li>
                                    <li><strong>Wrong package path:</strong> Package declaration must match folders.
                                    </li>
                                    <li><strong>Visibility issues:</strong> Accessing <code>private</code> members from
                                        outside the class.</li>
                                </ul>
                            </section>

                            <div>
                                <h2>Next Steps</h2>
                                <ol>
                                    <li>Create a new project and a class with <code>main</code>.</li>
                                    <li>Print some text, declare variables, and call a helper method.</li>
                                    <li>Refactor into multiple classes to practice files, packages, and imports.</li>
                                </ol>
                            </div>
                        </article>
                    </section>

                    <!-- Class 2 - recording -->
                    <section class="docs-section" id="item-1-4">
                        <h1 class="docs-heading">
                            Class 2 - Recording
                        </h1>
                        <a href="https://www.youtube.com/watch?v=0dI02p1RTec" target="_blank"
                            class="full-width-btn">
                            ‚ñ∂ Watch Video
                        </a>
                    </section>


                    <!-- Data Types -->
                    <section class="docs-section" id="item-1-5">
                        <h1 class="docs-heading">
                            Data Types
                        </h1>
                        <article>
                            <p>
                                In Java, <strong>data types</strong> define what kind of values a variable can hold and
                                how those values are stored and manipulated in memory.
                                Java is a <strong>statically typed</strong> and <strong>strongly typed</strong>
                                language, which means:
                            </p>
                            <ul>
                                <li>Every variable has a declared type at compile time.</li>
                                <li>Type conversions are explicit or follow well-defined rules.</li>
                            </ul>

                            <h2>High-Level Classification of Data Types</h2>
                            <ul>
                                <li><strong>Primitive Types</strong> ‚Äì built into the language, store simple values.
                                </li>
                                <li><strong>Reference Types</strong> ‚Äì objects, arrays, enums, interfaces, etc.</li>
                            </ul>

                            <h3>Primitive Data Types</h3>
                            <p>Java has 8 primitive data types:</p>
                            <ul>
                                <li><code>byte</code></li>
                                <li><code>short</code></li>
                                <li><code>int</code></li>
                                <li><code>long</code></li>
                                <li><code>float</code></li>
                                <li><code>double</code></li>
                                <li><code>char</code></li>
                                <li><code>boolean</code></li>
                            </ul>

                            <h3>1. Integer Types</h3>
                            <p>Used to store whole numbers (no decimal point).</p>

                            <h2><code>byte</code></h2>
                            <ul>
                                <li>Size: 8-bit signed integer.</li>
                                <li>Range: -128 to 127.</li>
                                <li>Use case: memory-sensitive contexts (large arrays of small numbers, streams, file
                                    I/O).</li>
                            </ul>
                            <pre><code>byte b = 100;
byte min = -128;
byte max = 127;</code></pre>

                            <h2><code>short</code></h2>
                            <ul>
                                <li>Size: 16-bit signed integer.</li>
                                <li>Range: -32,768 to 32,767.</li>
                                <li>Use case: rarely used; legacy code and some binary data formats.</li>
                            </ul>
                            <pre><code>short s = 32000;</code></pre>

                            <h2><code>int</code></h2>
                            <ul>
                                <li>Size: 32-bit signed integer.</li>
                                <li>Range: approx. -2.1 billion to 2.1 billion.</li>
                                <li><strong>Most commonly used</strong> integer type.</li>
                                <li>Default type for integer literals (e.g., <code>42</code> is an <code>int</code>).
                                </li>
                            </ul>
                            <pre><code>int count = 42;
int population = 1_000_000; // underscores for readability</code></pre>

                            <h2><code>long</code></h2>
                            <ul>
                                <li>Size: 64-bit signed integer.</li>
                                <li>Range: extremely large (~9.22e18).</li>
                                <li>Used when integer range of <code>int</code> is insufficient.</li>
                                <li>Requires <code>L</code> or <code>l</code> suffix for literals when exceeding
                                    <code>int</code> range.
                                </li>
                            </ul>
                            <pre><code>long big = 10_000_000_000L; // L is important</code></pre>

                            <h3>2. Floating-Point Types</h3>
                            <p>Used to represent numbers with fractional parts.</p>

                            <h2><code>float</code></h2>
                            <ul>
                                <li>Size: 32-bit IEEE 754 floating-point.</li>
                                <li>Precision: about 6‚Äì7 decimal digits.</li>
                                <li>Use case: large arrays of floating values where memory matters and some precision
                                    loss is acceptable.</li>
                                <li>Requires <code>f</code> or <code>F</code> suffix for literals.</li>
                            </ul>
                            <pre><code>float average = 3.14f; // 'f' or 'F' required</code></pre>

                            <h2><code>double</code></h2>
                            <ul>
                                <li>Size: 64-bit IEEE 754 floating-point.</li>
                                <li>Precision: about 15‚Äì16 decimal digits.</li>
                                <li><strong>Default type</strong> for floating-point literals (e.g., <code>3.14</code>
                                    is a <code>double</code>).</li>
                                <li>Most common floating-point type in Java.</li>
                            </ul>
                            <pre><code>double pi = 3.141592653589793;
double result = 1.0 / 3.0;</code></pre>

                            <h3>3. <code>char</code> Type</h3>
                            <ul>
                                <li>Size: 16-bit unsigned value.</li>
                                <li>Represents a single Unicode character.</li>
                                <li>Range: from <code>'\u0000'</code> to <code>'\uffff'</code>.</li>
                            </ul>
                            <pre><code>char letter = 'A';
char digit = '9';
char unicodeChar = '\u03A9'; // Greek capital letter Omega</code></pre>

                            <h3>4. <code>boolean</code> Type</h3>
                            <ul>
                                <li>Represents two values: <code>true</code> or <code>false</code>.</li>
                                <li>Commonly used in conditional statements and logical operations.</li>
                                <li>No defined size in the Java language specification (implementation-dependent).</li>
                            </ul>
                            <pre><code>boolean isJavaFun = true;
boolean isCold = false;</code></pre>

                            <h2>Reference (Non-Primitive) Data Types</h2>
                            <p>Reference types refer to objects stored in the heap. The variable holds a
                                <strong>reference</strong> (similar to an address) to the object.
                            </p>

                            <h3>1. Classes and Objects</h3>
                            <p>Any class you define is a reference type:</p>
                            <pre><code>class Person {
    String name;
    int age;
}

Person p = new Person();
p.name = "Alice";
p.age = 30;</code></pre>
                            <ul>
                                <li>Default value for an uninitialized reference field is <code>null</code>.</li>
                                <li>Accessing a member on a <code>null</code> reference throws
                                    <code>NullPointerException</code>.
                                </li>
                            </ul>

                            <h3>2. <code>String</code></h3>
                            <ul>
                                <li><code>String</code> is a <strong>reference type</strong>, not primitive.</li>
                                <li>Strings are <strong>immutable</strong>.</li>
                                <li>Literals are created with double quotes: <code>"Hello"</code>.</li>
                            </ul>
                            <pre><code>String message = "Hello, Java!";
String another = new String("Hello, Java!"); // usually not needed</code></pre>

                            <h3>3. Arrays</h3>
                            <ul>
                                <li>Arrays are objects and thus reference types.</li>
                                <li>They have a fixed length once created.</li>
                            </ul>
                            <pre><code>int[] numbers = new int[5];      // all elements initialized to 0
int[] values  = {1, 2, 3, 4, 5}; // array literal

System.out.println(values.length); // 5</code></pre>

                            <h3>4. Enums</h3>
                            <p>Enums are special reference types representing a fixed set of constants.</p>
                            <pre><code>enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

Day today = Day.MONDAY;</code></pre>

                            <h2>Enums in Java Overview</h2>
                            <p>Enums in Java are used to represent a fixed set of named constants, making your code
                                safer, more readable, and easier to maintain, especially when you want to restrict
                                possible values a variable can take, such as days of the week, months, colors, or
                                predefined states in a system.</p>

                            <h2>Common Use Cases for Enum in Java</h2>

                            <h3>Representing Fixed Categories</h3>
                            <p>Enums help define a set of constant values like days (MONDAY to SUNDAY), levels (LOW,
                                MEDIUM, HIGH), ticket categories (CRITICAL, HIGH, MEDIUM, LOW), or seasons (WINTER,
                                SPRING, SUMMER, AUTUMN).</p>

                            <h3>Control Flow Statements</h3>
                            <p>Enums are widely used in switch-case and if-else statements, for handling logic based on
                                these named values. This improves code clarity and reduces errors from using arbitrary
                                numbers or strings.</p>

                            <h3>Type Safety</h3>
                            <p>They ensure type safety by restricting values to those defined in the enum, unlike
                                traditional final static constants which can be any value.</p>

                            <h3>Grouping Related Constants</h3>
                            <p>Useful for grouping constants related by context, for example, status codes, user roles,
                                or configuration options in applications.</p>

                            <h2>Example of Using Enum</h2>
                            <pre>
    <code  class="language-java">enum TicketCategory {
    CRITICAL, HIGH, MEDIUM, LOW;
}

public class Main {
    public static void main(String[] args) {
        TicketCategory category = TicketCategory.HIGH;
        switch (category) {
            case CRITICAL:
                System.out.println("Critical ticket");
                break;
            case HIGH:
                System.out.println("High priority ticket");
                break;
            case MEDIUM:
                System.out.println("Medium priority ticket");
                break;
            case LOW:
                System.out.println("Low priority ticket");
                break;
        }
    }
}
</code>
</pre>
                            <p>This code demonstrates how enums define constant categories and integrate smoothly with
                                control statements like switch, improving code reliability and readability.</p>

                            <h2>Advanced Use</h2>

                            <h3>Enums with Methods and Fields</h3>
                            <p>Enums in Java can have methods, fields, and constructors, enabling them to store and
                                operate on more complex data, such as associating a value or description with each
                                constant.</p>

                            <h3>Interface Implementation</h3>
                            <p>Enums can implement interfaces to provide flexible code design patterns, such as
                                providing descriptions or custom behaviors for each constant.</p>

                            <h2>Conclusion</h2>
                            <p>Overall, enums in Java are preferred whenever you need a variable to accept only a
                                predetermined set of constant values, ensuring code safety and ease of maintenance.</p>




                            <h3>5. Interfaces, Records, and Other Reference Types</h3>
                            <ul>
                                <li><strong>Interfaces</strong> define contracts; implementation classes are reference
                                    types.</li>
                                <li><strong>Records</strong> (Java 16+) are special classes for immutable data carriers.
                                </li>
                            </ul>
                            <pre><code>record Point(int x, int y) {}

Point p = new Point(10, 20); // x=10, y=20</code></pre>
                            <p>In Java 16 and later, you can use a record to simplify classes that are mainly data
                                carriers. A record automatically provides private final fields, a constructor, getters,
                                equals(), hashCode(), and toString() methods, which greatly reduces boilerplate code.s
                            </p>

                            <h2>Wrapper Classes and Autoboxing</h2>

                            <p>Each primitive type has a corresponding wrapper class in <code>java.lang</code>:</p>
                            <ul>
                                <li><code>byte</code> ‚Üí <code>Byte</code></li>
                                <li><code>short</code> ‚Üí <code>Short</code></li>
                                <li><code>int</code> ‚Üí <code>Integer</code></li>
                                <li><code>long</code> ‚Üí <code>Long</code></li>
                                <li><code>float</code> ‚Üí <code>Float</code></li>
                                <li><code>double</code> ‚Üí <code>Double</code></li>
                                <li><code>char</code> ‚Üí <code>Character</code></li>
                                <li><code>boolean</code> ‚Üí <code>Boolean</code></li>
                            </ul>

                            <h2>Autoboxing and Unboxing</h2>
                            <p>
                                <strong>Autoboxing</strong> is automatic conversion from primitive to wrapper type.
                                <strong>Unboxing</strong> is the reverse.
                            </p>
                            <pre><code>Integer a = 10;   // autoboxing: int to Integer
int b = a;        // unboxing: Integer to int

List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(5);      // autoboxing
int x = list.get(0); // unboxing</code></pre>
                            <p><strong>Common pitfall:</strong> unboxing a <code>null</code> wrapper will throw
                                <code>NullPointerException</code>.
                            </p>
                            <pre><code>Integer n = null;
int y = n; // throws NullPointerException</code></pre>

                            <h2>Type Conversion and Casting</h2>

                            <h3>Widening Primitive Conversions (Safe, Implicit)</h3>
                            <p>Small type ‚Üí larger type, done automatically.</p>
                            <ul>
                                <li><code>byte ‚Üí short ‚Üí int ‚Üí long ‚Üí float ‚Üí double</code></li>
                                <li><code>char ‚Üí int ‚Üí long ‚Üí float ‚Üí double</code></li>
                            </ul>
                            <pre><code>int i = 100;
long l = i;       // OK, widening
double d = l;     // OK, widening</code></pre>

                            <h3>Narrowing Primitive Conversions (Explicit, Risky)</h3>
                            <p>Large type ‚Üí smaller type, requires explicit cast and may lose data.</p>
                            <pre><code>long big = 130L;
byte b = (byte) big; // overflow: result is -126

double v = 3.9;
int k = (int) v;     // k = 3, fractional part lost</code></pre>

                            <h3>Reference Type Casting</h3>
                            <p>
                                You can cast references within an inheritance hierarchy. Incorrect casts cause
                                <code>ClassCastException</code> at runtime.
                            </p>
                            <pre><code>Object obj = "Hello";
String str = (String) obj;      // OK

Object obj2 = Integer.valueOf(10);
String s = (String) obj2;       // ClassCastException at runtime</code></pre>

                            <h2>Default Values</h2>
                            <p>Default values apply to <strong>fields</strong> (instance or static), not to local
                                variables.</p>
                            <ul>
                                <li><code>byte, short, int, long</code> ‚Üí <code>0</code></li>
                                <li><code>float, double</code> ‚Üí <code>0.0</code></li>
                                <li><code>char</code> ‚Üí <code>'\u0000'</code></li>
                                <li><code>boolean</code> ‚Üí <code>false</code></li>
                                <li>Any reference type ‚Üí <code>null</code></li>
                            </ul>
                            <pre><code>class Example {
    int number;       // default 0
    boolean flag;     // default false
    String text;      // default null
}</code></pre>
                            <p>Local variables <strong>must</strong> be initialized before use or the code will not
                                compile.</p>

                            <h2>Newer Language Features Related to Types (Recent Java Versions)</h2>
                            <p>While the primitive data types themselves have not changed, newer Java versions added
                                features that affect how types are used and inferred.</p>

                            <h3>1. Local Variable Type Inference (<code>var</code>, Java 10+)</h3>
                            <p>
                                Java allows <code>var</code> for local variables, where the type is inferred by the
                                compiler.
                                <strong>Important:</strong> the variable still has a static type; <code>var</code> is
                                <em>not</em> dynamic typing.
                            </p>
                            <pre><code>var n = 10;          // inferred as int
var text = "Hello";  // inferred as String

// Still type-safe:
text = 20;           // compile-time error</code></pre>

                            <h3>2. Text Blocks for Strings (Java 13+)</h3>
                            <p>Multi-line string literals using <code>"""</code> are still <code>String</code> type.</p>
                            <pre><code>String json = """
{
  "name": "Alice",
  "age": 30
}
""";</code></pre>

                            <h3>3. Records (Java 16+)</h3>
                            <p>Records provide a concise syntax for classes that are mainly data carriers.</p>
                            <pre><code>record User(String name, int age) {}

User u = new User("Bob", 25);
String name = u.name();
int age = u.age();</code></pre>

                            <h3>4. Pattern Matching for <code>instanceof</code> (Java 16+)</h3>
                            <p>Makes type checking and casting more concise.</p>
                            <pre><code>Object obj = "Hello";
if (obj instanceof String s) {
    System.out.println(s.toUpperCase());
}</code></pre>

                            <h2>Common Exceptions Related to Data Types</h2>

                            <ul>
                                <li><strong><code>NullPointerException</code></strong>
                                    <ul>
                                        <li>Occurs when accessing a member or method on a <code>null</code> reference.
                                        </li>
                                    </ul>
                                    <pre><code>String s = null;
int len = s.length(); // NullPointerException</code></pre>
                                </li>

                                <li><strong><code>ClassCastException</code></strong>
                                    <ul>
                                        <li>Occurs when an invalid type cast is performed on a reference.</li>
                                    </ul>
                                    <pre><code>Object obj = Integer.valueOf(10);
String s = (String) obj; // ClassCastException</code></pre>
                                </li>

                                <li><strong><code>NumberFormatException</code></strong>
                                    <ul>
                                        <li>Occurs when converting a string to a numeric type fails.</li>
                                    </ul>
                                    <pre><code>int n = Integer.parseInt("abc"); // NumberFormatException</code></pre>
                                </li>

                                <li><strong><code>ArrayIndexOutOfBoundsException</code></strong>
                                    <ul>
                                        <li>Occurs when accessing an array index outside its bounds.</li>
                                    </ul>
                                    <pre><code>int[] arr = {1, 2, 3};
int x = arr[3]; // ArrayIndexOutOfBoundsException, valid indexes: 0..2</code></pre>
                                </li>

                                <li><strong><code>ArithmeticException</code></strong>
                                    <ul>
                                        <li>Commonly occurs on integer division by zero.</li>
                                    </ul>
                                    <pre><code>int a = 10;
int b = 0;
int c = a / b; // ArithmeticException: / by zero</code></pre>
                                </li>
                            </ul>

                            <h2>Most Commonly Mistaken Concepts About Java Data Types</h2>

                            <h3>1. <code>==</code> vs <code>equals()</code></h3>
                            <ul>
                                <li><code>==</code> compares <strong>references</strong> for objects (same memory
                                    location).</li>
                                <li><code>equals()</code> compares <strong>contents</strong> (if properly overridden).
                                </li>
                            </ul>
                            <pre><code>String a = new String("Java");
String b = new String("Java");

System.out.println(a == b);        // false (different objects)
System.out.println(a.equals(b));   // true (same content)</code></pre>

                            <h3>2. Treating <code>String</code> as a Primitive</h3>
                            <ul>
                                <li><code>String</code> is not primitive; it is a class in <code>java.lang</code>.</li>
                                <li>It behaves like a value in many scenarios, but it's still a reference.</li>
                            </ul>

                            <h3>3. Floating-Point Precision</h3>
                            <ul>
                                <li><code>float</code> and <code>double</code> are imprecise for some decimal values.
                                </li>
                                <li>Use <code>BigDecimal</code> for precise financial calculations.</li>
                            </ul>
                            <pre><code>double x = 0.1 + 0.2;
System.out.println(x); // may print 0.30000000000000004</code></pre>

                            <h3>4. Integer Division</h3>
                            <ul>
                                <li>Dividing two integers performs <strong>integer division</strong>, discarding the
                                    fractional part.</li>
                            </ul>
                            <pre><code>int a = 5;
int b = 2;
int c = a / b;    // 2, not 2.5
double d = a / b; // 2.0, still integer division first

double correct = a / 2.0; // 2.5</code></pre>

                            <h3>5. Overflow and Underflow</h3>
                            <ul>
                                <li>Primitive integer types (<code>byte</code>, <code>short</code>, <code>int</code>,
                                    <code>long</code>) overflow silently.
                                </li>
                            </ul>
                            <pre><code>int max = Integer.MAX_VALUE; // 2147483647
int overflow = max + 1;      // -2147483648 (wraps around)</code></pre>

                            <h3>6. Confusing <code>char</code> with <code>String</code></h3>
                            <ul>
                                <li><code>char</code> uses single quotes, <code>String</code> uses double quotes.</li>
                                <li><code>char</code> is a single 16-bit code unit, <code>String</code> is a sequence of
                                    characters.</li>
                            </ul>
                            <pre><code>char c = 'A';
String s = "A";</code></pre>

                            <h3>7. Assuming Arrays Grow Dynamically</h3>
                            <ul>
                                <li>Arrays in Java have fixed length.</li>
                                <li>To have dynamic growth, use collections like <code>ArrayList</code>.</li>
                            </ul>
                            <pre><code>int[] arr = new int[3];
// arr.length is always 3

List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(1);
list.add(2);
// list size can grow dynamically</code></pre>

                            <h3>8. Misusing Autoboxing and Caching</h3>
                            <p>
                                Wrapper classes cache some values (e.g., <code>Integer</code> from -128 to 127),
                                which can lead to confusion when using <code>==</code>.
                            </p>
                            <pre><code>Integer x = 127;
Integer y = 127;
System.out.println(x == y); // true (cached)

Integer m = 128;
Integer n = 128;
System.out.println(m == n); // false (different objects)
System.out.println(m.equals(n)); // true</code></pre>

                            <h3>9. Thinking <code>var</code> Means Dynamic Typing</h3>
                            <ul>
                                <li><code>var</code> does <strong>not</strong> mean the type can change.</li>
                                <li>Type is inferred once at compile time and cannot change later.</li>
                            </ul>

                            <h2>Best Practices When Working with Data Types in Java</h2>
                            <ul>
                                <li>Prefer <code>int</code> and <code>double</code> for general numeric work unless you
                                    have a specific reason to use others.</li>
                                <li>Use <code>long</code> for large ranges (e.g., IDs, timestamps).</li>
                                <li>Use <code>BigInteger</code> and <code>BigDecimal</code> for very large numbers or
                                    precise decimal arithmetic.</li>
                                <li>Avoid excessive autoboxing in performance-critical code (e.g., in loops) to reduce
                                    object creation.</li>
                                <li>Always check for <code>null</code> before unboxing wrapper types.</li>
                                <li>Use <code>equals()</code> to compare object content (especially
                                    <code>String</code>), not <code>==</code>.
                                </li>
                                <li>Be cautious with floating-point equality comparisons; use tolerances (epsilon)
                                    instead.</li>
                                <li>Initialize local variables before use; do not rely on defaults.</li>
                            </ul>

                            <h2>Summary</h2>
                            <p>
                                Java data types are divided into <strong>primitive</strong> and
                                <strong>reference</strong> types.
                                Understanding their sizes, ranges, default values, conversions, and common pitfalls is
                                essential for writing correct and efficient Java programs.
                                While newer Java versions have introduced features like <code>var</code>, records, text
                                blocks, and pattern matching, the core set of primitive types remains unchanged.
                            </p>
                        </article>
                    </section>
                    <!-- Variables -->
                    <section class="docs-section" id="item-1-6">
                        <h1 class="docs-heading">
                            Variables
                        </h1>
                        <article>
                            <p>
                                In Java, a <strong>variable</strong> is a named storage location in memory that holds a
                                value.
                                Java is <strong>statically typed</strong>, which means every variable has a declared
                                type
                                known at compile time.
                            </p>

                            <h2>Key Characteristics of Java Variables</h2>
                            <ul>
                                <li>Each variable has a <strong>name</strong>, a <strong>type</strong>, and a
                                    <strong>value</strong>.
                                </li>
                                <li>Type determines what operations can be performed on the variable.</li>
                                <li>Variables have <strong>scope</strong> (where they are visible) and
                                    <strong>lifetime</strong> (how long they exist).
                                </li>
                                <li>Java variables must be <strong>declared</strong> before use.</li>
                            </ul>

                            <h2>Basic Syntax</h2>
                            <pre><code>&lt;type&gt; &lt;variableName&gt; [= initialValue] ;

int count;
int age = 25;
String name = "Alice";</code></pre>

                            <ul>
                                <li><strong>Declaration</strong>: tells the compiler the type and name of the variable.
                                </li>
                                <li><strong>Initialization</strong>: gives the variable an initial value.</li>
                            </ul>

                            <h2>Classification of Variables</h2>

                            <h3>By Data Type</h3>
                            <ul>
                                <li><strong>Primitive type variables</strong> ‚Äì hold primitive values like
                                    <code>int</code>, <code>double</code>, <code>boolean</code>, etc.
                                </li>
                                <li><strong>Reference type variables</strong> ‚Äì hold references (addresses) to objects
                                    (e.g., <code>String</code>, arrays, custom classes).</li>
                            </ul>

                            <h3>By Scope / Where They Are Declared</h3>
                            <ul>
                                <li><strong>Local variables</strong> ‚Äì declared inside methods, constructors, or blocks.
                                </li>
                                <li><strong>Parameter variables</strong> ‚Äì declared in method or constructor parameter
                                    lists.</li>
                                <li><strong>Instance variables (fields)</strong> ‚Äì non-static fields declared in a
                                    class.</li>
                                <li><strong>Static variables (class variables)</strong> ‚Äì fields declared with
                                    <code>static</code>.
                                </li>
                            </ul>

                            <h2>Local Variables</h2>
                            <p>Local variables are declared inside methods, constructors, or blocks and exist only
                                within that scope.</p>
                            <pre><code>void doSomething() {
    int x = 10;           // local variable
    if (x &gt; 5) {
        int y = 20;       // local to the if-block
        System.out.println(y);
    }
    // y is not visible here
}</code></pre>

                            <ul>
                                <li>No default values ‚Äì <strong>must</strong> be initialized before use (otherwise
                                    compile-time error).</li>
                                <li>Stored on the <strong>stack</strong> (conceptually) and destroyed when the method
                                    finishes.</li>
                            </ul>

                            <h2>Parameter Variables</h2>
                            <p>
                                Parameters are variables declared in a method or constructor‚Äôs parameter list. They
                                receive values when the method is called.
                            </p>
                            <pre><code>void greet(String name, int times) {  // name and times are parameters
    for (int i = 0; i &lt; times; i++) {
        System.out.println("Hello " + name);
    }
}</code></pre>

                            <ul>
                                <li>Parameters are treated like local variables inside the method.</li>
                                <li>They must have a type and a name.</li>
                            </ul>

                            <h2>Instance Variables (Fields)</h2>
                            <p>Instance variables belong to an <strong>object</strong> (instance of the class).</p>
                            <pre><code>class Person {
    String name;    // instance variable
    int age;        // instance variable

    void introduce() {
        System.out.println("My name is " + name);
    }
}</code></pre>

                            <ul>
                                <li>Each object has its own copy of instance variables.</li>
                                <li>Default values apply if not initialized explicitly (e.g., 0, <code>false</code>,
                                    <code>null</code>).
                                </li>
                                <li>Accessible via <code>this.name</code>, though <code>this</code> is usually optional.
                                </li>
                            </ul>

                            <h2>Static Variables (Class Variables)</h2>
                            <p>Static variables belong to the <strong>class itself</strong>, not to any particular
                                object.</p>
                            <pre><code>class Counter {
    static int count = 0; // static variable

    Counter() {
        count++;
    }
}

Counter c1 = new Counter();
Counter c2 = new Counter();
System.out.println(Counter.count); // 2</code></pre>

                            <ul>
                                <li>Shared among all instances of the class.</li>
                                <li>Accessed via class name: <code>ClassName.variableName</code>.</li>
                                <li>Useful for constants and shared state (e.g., caches, counters).</li>
                            </ul>

                            <h2>Variable Initialization</h2>

                            <h3>1. Explicit Initialization</h3>
                            <pre><code>int x = 10;
String message = "Hello";</code></pre>

                            <h3>2. Default Initialization (Fields Only)</h3>
                            <pre><code>class Example {
    int n;         // default 0
    boolean flag;  // default false
    String text;   // default null
}</code></pre>

                            <p>Local variables <strong>do not</strong> get default values and must be initialized before
                                use.</p>

                            <h3>3. Multiple Declarations</h3>
                            <pre><code>int a, b, c;
int x = 1, y = 2, z = 3;</code></pre>

                            <p>For clarity, it is often better to declare one variable per line.</p>

                            <h2>Final Variables (Constants)</h2>
                            <p>A <code>final</code> variable can be assigned only once.</p>
                            <pre><code>final int MAX_SIZE = 100;
final String APP_NAME = "MyApp";</code></pre>

                            <ul>
                                <li>After assignment, the value cannot be changed.</li>
                                <li>For reference types, the <strong>reference</strong> cannot change, but the object it
                                    points to may be mutable.</li>
                            </ul>
                            <pre><code>final List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add("A");    // OK, modifying the object
// list = new ArrayList&lt;&gt;(); // Error: cannot assign a value to final variable</code></pre>

                            <h2>Blank Final Variables</h2>
                            <p>Final variables that are declared but not initialized immediately, typically assigned in
                                the constructor.</p>
                            <pre><code>class User {
    final String id; // blank final

    User(String id) {
        this.id = id; // must be assigned here
    }
}</code></pre>

                            <h2>Effectively Final Variables</h2>
                            <p>
                                A variable is <strong>effectively final</strong> if it is assigned only once, even
                                without the <code>final</code> keyword.
                                This is important for anonymous classes and lambdas.
                            </p>
                            <pre><code>void test() {
    int base = 10; // effectively final
    Runnable r = () -&gt; System.out.println(base); // allowed
}</code></pre>

                            <h2>Local Variable Type Inference (<code>var</code>, Java 10+)</h2>
                            <p>
                                Java supports <strong>local variable type inference</strong> using <code>var</code> for
                                local variables
                                with initializers. The type is inferred by the compiler.
                            </p>

                            <pre><code>var number = 10;           // inferred as int
var text = "Hello";        // inferred as String
var list = new ArrayList&lt;String&gt;(); // inferred as ArrayList&lt;String&gt;</code></pre>

                            <ul>
                                <li><code>var</code> can only be used for <strong>local variables</strong>,
                                    <strong>for-each</strong> variables, and <strong>traditional for-loop</strong>
                                    indices.
                                </li>
                                <li>Cannot be used for fields, method parameters, or return types.</li>
                                <li>Variable still has a single, static type ‚Äì Java is <strong>not</strong> dynamically
                                    typed.</li>
                                <li>Requires an initializer (you cannot write just <code>var x;</code>).</li>
                            </ul>

                            <pre><code>// Invalid uses:
var x;                    // Error: cannot use 'var' without initializer
var nothing = null;       // Error: cannot infer type from null alone</code></pre>

                            <h2>Naming Variables</h2>
                            <ul>
                                <li>Use <strong>camelCase</strong> for variables and methods: <code>totalAmount</code>,
                                    <code>userName</code>.
                                </li>
                                <li>Use <strong>UPPER_SNAKE_CASE</strong> for <code>static final</code> constants:
                                    <code>MAX_VALUE</code>.
                                </li>
                                <li>Names must start with a letter, <code>$</code>, or <code>_</code>, and can contain
                                    digits after that.</li>
                                <li>Avoid using <code>$</code> and <code>_</code> unless you have a special reason.</li>
                                <li>Must not be a Java keyword (like <code>int</code>, <code>class</code>,
                                    <code>for</code>).
                                </li>
                            </ul>

                            <h2>Scope and Lifetime</h2>

                            <h3>1. Block Scope</h3>
                            <pre><code>if (condition) {
    int a = 10;   // a is visible only inside this block
}
// a is not visible here</code></pre>

                            <h3>2. Method Scope</h3>
                            <p>Local variables declared in a method are not visible outside that method.</p>

                            <h3>3. Class Scope</h3>
                            <p>Instance and static variables are visible to all methods of the class (subject to access
                                modifiers).</p>

                            <h2>Shadowing</h2>
                            <p>
                                A local or parameter variable can <strong>shadow</strong> a field with the same name.
                                Use <code>this</code> to refer to the field.
                            </p>
                            <pre><code>class Example {
    int value;

    Example(int value) {
        this.value = value; // 'this.value' is the field, 'value' is parameter
    }
}</code></pre>

                            <h2>Variables and Memory</h2>
                            <ul>
                                <li><strong>Local variables and parameters</strong> live on the stack (conceptually) and
                                    are destroyed when the method returns.</li>
                                <li><strong>Instance and static variables</strong> are part of objects or class metadata
                                    stored on the heap.</li>
                                <li>Reference variables hold an address pointing to an object on the heap.</li>
                            </ul>

                            <h2>Common Errors and Exceptions Related to Variables</h2>

                            <h3>Compile-Time Errors (Not Exceptions)</h3>
                            <ul>
                                <li><strong>"variable might not have been initialized"</strong> ‚Äì using a local variable
                                    before assigning a value.</li>
                                <li><strong>"cannot find symbol"</strong> ‚Äì using a variable name that is out of scope
                                    or not declared.</li>
                                <li><strong>"variable x is already defined in method"</strong> ‚Äì declaring two variables
                                    with the same name in the same scope.</li>
                            </ul>

                            <pre><code>void example() {
    int x;
    // System.out.println(x); // Error: variable x might not have been initialized
}</code></pre>

                            <h3>Runtime Exceptions (Caused by Incorrect Use of Variables)</h3>
                            <ul>
                                <li><strong>NullPointerException</strong> ‚Äì using a reference variable that is
                                    <code>null</code>.
                                </li>
                                <li><strong>ArrayIndexOutOfBoundsException</strong> ‚Äì using an array index outside the
                                    valid range.</li>
                                <li><strong>ClassCastException</strong> ‚Äì incorrect casting of objects referenced by
                                    variables.</li>
                            </ul>

                            <pre><code>String s = null;
s.length(); // NullPointerException

int[] arr = new int[3];
arr[3] = 10; // ArrayIndexOutOfBoundsException</code></pre>

                            <h2>Most Commonly Mistaken Concepts About Variables in Java</h2>

                            <h3>1. Java Is Pass-by-Value (Always)</h3>
                            <p>
                                Many people think objects are passed by reference. In reality, Java passes the
                                <strong>value of the reference</strong> (a copy of the reference).
                            </p>
                            <pre><code>void modify(int x) {
    x = 10;
}

void modify(StringBuilder sb) {
    sb.append(" world");
}

int a = 5;
modify(a);
System.out.println(a); // still 5

StringBuilder sb = new StringBuilder("Hello");
modify(sb);
System.out.println(sb); // Hello world</code></pre>
                            <p>
                                Changing the reference variable itself does not affect the caller, but modifying
                                the object it points to does.
                            </p>

                            <h3>2. Confusing <code>=</code> with <code>==</code></h3>
                            <ul>
                                <li><code>=</code> is <strong>assignment</strong>.</li>
                                <li><code>==</code> is <strong>comparison</strong>.</li>
                            </ul>

                            <h3>3. Using <code>==</code> for Strings and Objects</h3>
                            <p>
                                <code>==</code> compares whether two reference variables point to the <strong>same
                                    object</strong>,
                                not whether their values are equal. Use <code>equals()</code> for value equality.
                            </p>
                            <pre><code>String a = new String("Java");
String b = new String("Java");

System.out.println(a == b);      // false (different objects)
System.out.println(a.equals(b)); // true (same content)</code></pre>

                            <h3>4. Assuming Local Variables Have Default Values</h3>
                            <p>Local variables <strong>must</strong> be initialized before use; there are no automatic
                                defaults.</p>

                            <h3>5. Misunderstanding <code>static</code> vs Instance Variables</h3>
                            <ul>
                                <li>Static variables are shared across all instances.</li>
                                <li>Instance variables are unique to each object.</li>
                            </ul>
                            <p>Accidentally using static variables for per-object state leads to bugs.</p>

                            <h3>6. Thinking <code>var</code> Makes Java Dynamically Typed</h3>
                            <ul>
                                <li>With <code>var</code>, the compiler still decides a single, fixed type at compile
                                    time.</li>
                                <li>You cannot assign a different type later.</li>
                            </ul>
                            <pre><code>var x = 10;  // int
// x = "Hello"; // Error: incompatible types</code></pre>

                            <h3>7. Variable Shadowing Confusion</h3>
                            <p>Forgetting that a local or parameter variable shadows a field can lead to unexpected
                                behavior.</p>
                            <pre><code>class Demo {
    int value = 5;

    void setValue(int value) {
        value = value;        // assigns parameter to itself, field unchanged
    }
}</code></pre>
                            <p>Correct version uses <code>this</code>:</p>
                            <pre><code>void setValue(int value) {
    this.value = value;       // assigns parameter to field
}</code></pre>

                            <h2>Newer Language Features Related to Variables</h2>

                            <h3>1. <code>var</code> (Java 10+)</h3>
                            <ul>
                                <li>Reduces verbosity in local variable declarations.</li>
                                <li>Particularly useful with generics and complex types.</li>
                            </ul>

                            <h3>2. Pattern Variables in <code>instanceof</code> (Java 16+)</h3>
                            <p>
                                Pattern matching introduces <strong>pattern variables</strong> that combine type tests
                                and casts.
                            </p>
                            <pre><code>Object obj = "Hello";
if (obj instanceof String s) { // s is a pattern variable
    System.out.println(s.toUpperCase());
}</code></pre>

                            <h3>3. Pattern Matching for <code>switch</code> (Newer Java Versions)</h3>
                            <p>
                                Enhanced <code>switch</code> expressions and pattern matching introduce variables bound
                                in
                                <code>case</code> labels, making code more expressive while still being statically
                                typed.
                            </p>

                            <h2>Best Practices for Variables in Java</h2>
                            <ul>
                                <li>Use <strong>meaningful names</strong> that clearly describe the purpose of the
                                    variable.</li>
                                <li>Keep variable <strong>scope as small as possible</strong> to reduce bugs and improve
                                    readability.</li>
                                <li>Prefer <strong>immutable</strong> variables where possible (<code>final</code> and
                                    effectively final).</li>
                                <li>Avoid using magic numbers; use <strong>constants</strong>
                                    (<code>static final</code>) instead.</li>
                                <li>Initialize variables close to where they are used.</li>
                                <li>Be careful with <strong>static</strong> variables; overuse can lead to tight
                                    coupling and hidden dependencies.</li>
                                <li>Use <code>var</code> when it improves readability, not just to save typing.</li>
                            </ul>



                            <h2>Summary</h2>
                            <p>
                                Variables in Java are fundamental building blocks that represent named storage locations
                                associated with types.
                                Understanding the different kinds of variables (local, parameter, instance, static),
                                their scope, lifetime,
                                initialization rules, and how they interact with newer language features like
                                <code>var</code> and pattern matching
                                is essential to writing clean, correct, and maintainable Java code. Many common bugs
                                arise from misunderstandings
                                about variable scope, initialization, and object references, so paying attention to
                                these details is critical.
                            </p>


                            <h2>Type Casting in Java</h2>

                            <p>
                                <strong>Type casting</strong> in Java means converting a value of one data type into
                                another compatible data type.
                                There are two main categories:
                            </p>
                            <ul>
                                <li><strong>Primitive casting</strong> (between <code>int</code>, <code>double</code>,
                                    etc.)</li>
                                <li><strong>Reference casting</strong> (between classes in the same inheritance
                                    hierarchy)</li>
                            </ul>

                            <h3>1. Primitive Type Casting</h3>

                            <h3>1.1 Widening Casting (Automatic / Implicit)</h3>
                            <p>
                                Small type ‚Üí bigger type. This is safe and done automatically by Java.
                            </p>
                            <p><strong>Order:</strong> <code>byte ‚Üí short ‚Üí int ‚Üí long ‚Üí float ‚Üí double</code></p>
                            <pre><code>int i = 10;
double d = i;   // int to double (automatic)
long  l = i;    // int to long   (automatic)</code></pre>

                            <h3>1.2 Narrowing Casting (Manual / Explicit)</h3>
                            <p>
                                Bigger type ‚Üí smaller type. This can lose data, so you must cast
                                <strong>explicitly</strong>
                                using <code>(targetType)</code>.
                            </p>
                            <pre><code>double d = 9.7;
int i = (int) d;   // i = 9, fractional part is lost

long  big = 130L;
byte  b   = (byte) big; // overflow, b = -126</code></pre>

                            <p><strong>Syntax:</strong></p>
                            <pre><code>&lt;targetType&gt; variable = (&lt;targetType&gt;) value;</code></pre>

                            <h3>1.3 Common Examples</h3>
                            <pre><code>float f = 3.14f;
double d = f;           // widening, OK

double x = 3.99;
int    y = (int) x;     // narrowing, need (int)

short s = 100;
byte  bb = (byte) s;    // narrowing, need (byte)</code></pre>

                            <h3>1.4 Casting vs Parsing (for Strings)</h3>
                            <p>
                                You <strong>cannot</strong> cast a <code>String</code> directly to a number. Use parsing
                                methods:
                            </p>
                            <pre><code>String s = "123";
// int n = (int) s;       // ‚ùå compile error

int n = Integer.parseInt(s);   // ‚úî correct
double d = Double.parseDouble("3.14");</code></pre>

                            <h2>2. Reference Type Casting (Objects)</h2>

                            <p>
                                For reference types, you can cast only within the same <strong>inheritance
                                    hierarchy</strong>.
                                There are two concepts:
                            </p>
                            <ul>
                                <li><strong>Upcasting</strong> ‚Äì child ‚Üí parent (implicit)</li>
                                <li><strong>Downcasting</strong> ‚Äì parent ‚Üí child (explicit, may fail at runtime)</li>
                            </ul>

                            <h3>2.1 Upcasting (Safe, Automatic)</h3>
                            <pre><code>class Animal {
    void speak() { System.out.println("Animal"); }
}

class Dog extends Animal {
    void bark() { System.out.println("Woof"); }
}

Dog d = new Dog();
Animal a = d;    // upcasting: Dog ‚Üí Animal (automatic)</code></pre>

                            <p>
                                Upcasting is always safe because a <code>Dog</code> <em>is an</em> <code>Animal</code>.
                            </p>

                            <h3>2.2 Downcasting (Manual, Can Throw Exception)</h3>
                            <p>
                                Downcasting means casting a parent reference back to a child type. You must do it
                                explicitly, and it
                                can throw <code>ClassCastException</code> if the actual object is not of that type.
                            </p>
                            <pre><code>Animal a = new Dog();      // upcast
Dog d = (Dog) a;           // downcast, OK at runtime

Animal a2 = new Animal();
// Dog d2 = (Dog) a2;      // compiles, but at runtime: ClassCastException</code></pre>

                            <h3>2.3 Use <code>instanceof</code> Before Downcasting</h3>
                            <p>
                                To avoid <code>ClassCastException</code>, you should check with <code>instanceof</code>:
                            </p>
                            <pre><code>Animal a = getAnimal();  // returns some Animal

if (a instanceof Dog) {
    Dog d = (Dog) a;     // safe downcast
    d.bark();
} else {
    System.out.println("Not a Dog");
}</code></pre>

                            <h3>2.4 Pattern Matching <code>instanceof</code> (Newer Java)</h3>
                            <p>Modern Java lets you combine <code>instanceof</code> and cast:</p>
                            <pre><code>if (a instanceof Dog d) {
    d.bark();   // d is already a Dog
}</code></pre>

                            <h2>3. Important Notes About Casting</h2>
                            <ul>
                                <li>Casting does <strong>not change</strong> the variable‚Äôs declared type, only the
                                    value in that expression.</li>
                            </ul>
                            <pre><code>double d = 5.9;
int x = (int) d;  // cast only here
// d is still double, only x is int</code></pre>

                            <ul>
                                <li>You can only cast between <strong>compatible</strong> types (same hierarchy for
                                    objects, numeric types for primitives).</li>
                                <li>Casting does <strong>not</strong> create a new object for reference types; it just
                                    treats the same object as another type.</li>
                            </ul>

                            <h2>4. Quick Cheat Sheet</h2>
                            <ul>
                                <li><strong>Primitive widening</strong> ‚Äì automatic:
                                    <code>int i = 10; double d = i;</code>
                                </li>
                                <li><strong>Primitive narrowing</strong> ‚Äì need cast:
                                    <code>double d = 9.8; int i = (int) d;</code>
                                </li>
                                <li><strong>Upcasting (child ‚Üí parent)</strong> ‚Äì automatic:
                                    <code>Animal a = new Dog();</code>
                                </li>
                                <li><strong>Downcasting (parent ‚Üí child)</strong> ‚Äì explicit:
                                    <code>Dog d = (Dog) a;</code>
                                </li>
                                <li><strong>Strings to numbers</strong> ‚Äì use <code>parseInt</code>,
                                    <code>parseDouble</code>, etc., not casting.
                                </li>
                                <li>Use <code>instanceof</code> to check before downcasting to avoid
                                    <code>ClassCastException</code>.
                                </li>
                            </ul>
                        </article>
                    </section>

                    
                    
                    <!-- Class 3 - recording -->
                    <section class="docs-section" id="item-1-7">
                        <h1 class="docs-heading">
                            Class 3 - Recording
                        </h1>
                        <a href="https://www.youtube.com/watch?v=2xt0NjpqsPk" target="_blank"
                            class="full-width-btn">
                            ‚ñ∂ Watch Video
                        </a>
                    </section>

                    <!-- Control Flow Section - inserted -->
                    <section class="docs-section" id="item-1-8">
                        <h1 class="docs-heading">Control Flow in Programming</h1>
                        <article>
                            <p>
                                Control flow is the order in which individual statements, instructions, or function
                                calls
                                are executed or evaluated in a program. By default, code runs from top to bottom, but
                                control-flow constructs (like <strong>if</strong>, <strong>loops</strong>, and
                                <strong>switch</strong>) let you change that order.
                            </p>

                            <h2>Table of Contents</h2>
                            <ol>
                                <li><a href="#core-concepts">Core Concepts</a></li>
                                <li><a href="#if-statements">If Statements</a></li>
                                <li><a href="#loops">Loops</a></li>
                                <li><a href="#switch">Switch Statements</a></li>
                                <li><a href="#exceptions">Exceptions (Error Handling)</a></li>
                                <li><a href="#import-all">What Is ‚ÄúImport All‚Äù?</a></li>
                            </ol>

                            <section id="core-concepts">
                                <h2>1. Core Concepts of Control Flow</h2>
                                <p>Most programs execute in three basic ways:</p>
                                <ul>
                                    <li><strong>Sequential</strong> ‚Äì instructions run one after another.</li>
                                    <li><strong>Selection (branching)</strong> ‚Äì choose different paths (e.g.,
                                        <code>if</code>, <code>switch</code>).
                                    </li>
                                    <li><strong>Iteration (looping)</strong> ‚Äì repeat blocks of code (e.g.,
                                        <code>for</code>, <code>while</code>).
                                    </li>
                                </ul>

                                <h3>Simple Example (Pseudo-Code)</h3>
                                <pre><code>// Pseudo-code example of basic control flow

read age

if (age &gt;= 18) {
    print("You are an adult");
} else {
    print("You are not an adult");
}

for (i = 0; i &lt; 3; i = i + 1) {
    print("Loop iteration: " + i);
}</code></pre>
                            </section>

                            <section id="if-statements">
                                <h2>2. If Statements (Selection)</h2>
                                <p>
                                    <strong>If statements</strong> allow your program to make decisions. A condition is
                                    evaluated, and
                                    if it is true, a block of code is executed; otherwise, it is skipped or an
                                    alternative block is run.
                                </p>

                                <h3>Basic Syntax (C / Java / JavaScript Style)</h3>
                                <pre><code>if (condition) {
    // code that runs when condition is true
} else {
    // code that runs when condition is false
}</code></pre>

                                <h3>Else If Chains</h3>
                                <pre><code>int score = 85;

if (score &gt;= 90) {
    printf("Grade: A\n");
} else if (score &gt;= 80) {
    printf("Grade: B\n");
} else if (score &gt;= 70) {
    printf("Grade: C\n");
} else {
    printf("Grade: F\n");
}</code></pre>

                                <h3>Common Pitfalls / ‚ÄúExceptions‚Äù in Behavior</h3>
                                <ul>
                                    <li><strong>Assignment vs comparison:</strong> Using <code>=</code> instead of
                                        <code>==</code> in some languages can cause bugs.
                                    </li>
                                    <li><strong>Truthiness:</strong> In some languages, non-boolean values (like 0,
                                        empty strings, null) are treated as false.</li>
                                    <li><strong>Missing braces:</strong> Omitting <code>{ }</code> can make only one
                                        line part of the <code>if</code>, not the whole block you intended.</li>
                                </ul>
                            </section>

                            <section id="loops">
                                <h2>3. Loops (Iteration)</h2>
                                <p>
                                    <strong>Loops</strong> allow you to repeat a block of code multiple times. They are
                                    essential for
                                    tasks like processing lists, counting, and waiting for a condition to change.
                                </p>

                                <h3>3.1 For Loop</h3>
                                <p>A <strong>for loop</strong> is used when you know (or can calculate) how many times
                                    you want to repeat.</p>
                                <pre><code>// C / Java / JavaScript style for loop
for (int i = 0; i &lt; 5; i++) {
    printf("i = %d\n", i);
}</code></pre>

                                <h3>Key Parts of a For Loop</h3>
                                <ul>
                                    <li><strong>Initialization</strong> ‚Äì run once before the loop starts (e.g.,
                                        <code>int i = 0</code>).
                                    </li>
                                    <li><strong>Condition</strong> ‚Äì checked before each iteration (e.g.,
                                        <code>i &lt; 5</code>).
                                    </li>
                                    <li><strong>Update</strong> ‚Äì executed after each iteration (e.g.,
                                        <code>i++</code>).
                                    </li>
                                </ul>

                                <h3>3.2 While Loop</h3>
                                <pre><code>int count = 0;

while (count &lt; 3) {
    printf("count = %d\n", count);
    count++;
}</code></pre>

                                <h3>3.3 Do-While Loop</h3>
                                <pre><code>int x = 0;

do {
    printf("x = %d\n", x);
    x++;
} while (x &lt; 3);</code></pre>

                                <h3>Breaking and Skipping in Loops</h3>
                                <ul>
                                    <li><strong>break</strong> ‚Äì exit the loop immediately.</li>
                                    <li><strong>continue</strong> ‚Äì skip to the next iteration of the loop.</li>
                                </ul>

                                <pre><code>for (int i = 0; i &lt; 10; i++) {
    if (i == 3) {
        continue;   // skip when i is 3
    }
    if (i == 8) {
        break;      // stop the loop entirely
    }
    printf("i = %d\n", i);
}</code></pre>

                                <h3>Common Loop ‚ÄúExceptions‚Äù and Pitfalls</h3>
                                <ul>
                                    <li><strong>Infinite loops:</strong> If the condition never becomes false, the loop
                                        never ends.</li>
                                    <li><strong>Off-by-one errors:</strong> Using <code>&lt;=</code> instead of
                                        <code>&lt;</code> (or vice versa) can loop one time too many or too few.
                                    </li>
                                    <li><strong>Modifying the loop variable incorrectly:</strong> Skipping values or
                                        causing unexpected behavior.</li>
                                </ul>
                            </section>

                            <section id="switch">
                                <h2>4. Switch Statements</h2>
                                <p>
                                    A <strong>switch statement</strong> lets you compare a single value against many
                                    possible cases.
                                    It can be cleaner than a long chain of <code>if / else if / else</code>.
                                </p>

                                <h3>Basic Syntax</h3>
                                <pre><code>int day = 3;

switch (day) {
    case 1:
        printf("Monday\n");
        break;
    case 2:
        printf("Tuesday\n");
        break;
    case 3:
        printf("Wednesday\n");
        break;
    default:
        printf("Unknown day\n");
        break;
}</code></pre>

                                <h3>Important Concepts</h3>
                                <ul>
                                    <li><strong>case label:</strong> A specific value to match against (e.g.,
                                        <code>case 1:</code>).
                                    </li>
                                    <li><strong>break:</strong> Prevents ‚Äúfall-through‚Äù to the next case.</li>
                                    <li><strong>default:</strong> Code that runs if no case matches.</li>
                                </ul>

                                <h3>Fall-Through Behavior</h3>
                                <p>
                                    In many languages (like C, C++, Java, JavaScript), if you omit <code>break</code>,
                                    execution continues into the next case. This can be useful but also a common source
                                    of bugs.
                                </p>
                            </section>

                            <section id="exceptions">
                                <h2>5. Exceptions (Error Handling Control Flow)</h2>
                                <p>
                                    <strong>Exceptions</strong> are an additional type of control flow used for handling
                                    errors or
                                    unusual situations. Instead of returning error codes, an exception can be ‚Äúthrown‚Äù
                                    and then
                                    ‚Äúcaught‚Äù by a special block of code.
                                </p>

                                <h3>Basic Example (Java-like Syntax)</h3>
                                <pre><code>try {
    int result = 10 / 0; // this will cause an error (division by zero)
    System.out.println("Result: " + result);
} catch (ArithmeticException e) {
    System.out.println("Error: " + e.getMessage());
} finally {
    System.out.println("This always runs (cleanup, closing files, etc.)");
}</code></pre>
                            </section>

                            <section id="import-all">
                                <h2>6. What Is ‚ÄúImport All‚Äù?</h2>
                                <p>
                                    <strong>‚ÄúImport all‚Äù</strong> usually refers to importing everything (all functions,
                                    classes, variables)
                                    from a module or package into the current scope. This is more about <strong>module
                                        organization</strong>
                                    than control flow itself, but it influences how code is accessed and executed.
                                </p>

                                <h3>Examples in Different Languages</h3>
                                <h3>Python</h3>
                                <pre><code># Import everything from the math module into the current namespace
from math import *

print(sqrt(16))  # sqrt is available directly</code></pre>

                                <h3>JavaScript (ES Modules)</h3>
                                <pre><code>// Import everything from 'utils.js' as an object called utils
import * as utils from './utils.js';

console.log(utils.add(2, 3));</code></pre>

                                <h3>Java</h3>
                                <pre><code>// Import all classes from java.util package
import java.util.*;

public class Example {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
    }
}</code></pre>

                                <h3>Pros and Cons of Import All</h3>
                                <h3>Pros</h3>
                                <ul>
                                    <li>Convenient: You do not need to list every single item you use.</li>
                                    <li>Shorter code in small scripts or quick experiments.</li>
                                </ul>

                                <h3>Cons</h3>
                                <ul>
                                    <li><strong>Name conflicts:</strong> If two modules define the same name, ‚Äúimport
                                        all‚Äù can cause collisions.</li>
                                    <li><strong>Less readable:</strong> It becomes harder to see where a function or
                                        class comes from.</li>
                                    <li><strong>Potential performance or bundle-size issues:</strong> In some
                                        environments, importing everything may load more code than necessary.</li>
                                </ul>

                                <p><strong>Best Practice:</strong> Import only what you need, or import using a
                                    namespace (like <code>import * as utils</code>), to keep code clear and
                                    maintainable.</p>
                            </section>

                            <footer>
                                <hr>
                                <p>
                                    Summary: Control flow constructs like <strong>if</strong>, <strong>loops</strong>,
                                    and
                                    <strong>switch</strong> determine how your program moves from one instruction to the
                                    next.
                                    Exceptions provide a way to handle errors gracefully, and ‚Äúimport all‚Äù affects how
                                    you organize
                                    and access code across modules.
                                </p>
                            </footer>
                        </article>
                    </section>
                    <!--//Control Flow Section-->

                    <!-- Debugging Section - inserted -->
                    <section class="docs-section" id="item-1-9">

                        <h1 class="docs-heading">Debugging Basics (Using IntelliJ IDEA)</h1>
                        <p>
                            Debugging is the process of finding and fixing errors (bugs) in your code.
                            IntelliJ IDEA provides a powerful debugger that lets you pause your program,
                            inspect variables, run code step-by-step, and understand exactly what is happening.
                        </p>
                        </header>

                        <nav>
                            <h2>Table of Contents</h2>
                            <ol>
                                <li><a href="#core-concepts">Core Debugging Concepts</a></li>
                                <li><a href="#setup-run-config">Setting Up &amp; Running in Debug Mode</a></li>
                                <li><a href="#breakpoints">Breakpoints</a></li>
                                <li><a href="#debug-controls">Debug Controls (Step Over, Into, Out)</a></li>
                                <li><a href="#inspecting-state">Inspecting Variables &amp; Expressions</a></li>
                                <li><a href="#conditional-log-breakpoints">Conditional &amp; Log Breakpoints</a></li>
                                <li><a href="#debugging-exceptions">Debugging Exceptions</a></li>
                                <li><a href="#example-workflow">Example Debugging Workflow</a></li>
                                <li><a href="#tips-mistakes">Tips &amp; Common Mistakes</a></li>
                            </ol>
                        </nav>

                        <!-- Core Concepts -->
                        <section id="core-concepts">
                            <h2>1. Core Debugging Concepts</h2>
                            <p>Important terms you will see when debugging:</p>
                            <ul>
                                <li><strong>Breakpoint</strong> ‚Äì a marker in your code where the debugger will pause
                                    execution.</li>
                                <li><strong>Call stack</strong> ‚Äì the list of methods/functions that have been called to
                                    reach the current point.</li>
                                <li><strong>Step over</strong> ‚Äì run the current line and go to the next one (skips
                                    inside method bodies).</li>
                                <li><strong>Step into</strong> ‚Äì move into the method being called on the current line.
                                </li>
                                <li><strong>Step out</strong> ‚Äì finish the current method and return to the caller.</li>
                                <li><strong>Watch</strong> ‚Äì a variable or expression that you keep an eye on while
                                    debugging.</li>
                                <li><strong>Evaluate expression</strong> ‚Äì run small pieces of code during a pause to
                                    inspect behavior.</li>
                            </ul>
                        </section>

                        <!-- Setup & Run Config -->
                        <section id="setup-run-config">
                            <h2>2. Setting Up &amp; Running in Debug Mode (IntelliJ IDEA)</h2>
                            <h3>2.1 Create a Run/Debug Configuration</h3>
                            <ol>
                                <li>At the top-right of IntelliJ, locate the run configuration dropdown.</li>
                                <li>Click it and choose <strong>Edit Configurations...</strong>.</li>
                                <li>
                                    Create a new configuration (for example, <strong>Application</strong> for Java):
                                    <ul>
                                        <li>Set the <strong>Main class</strong> (the class with <code>main()</code>).
                                        </li>
                                        <li>Choose the correct <strong>Module</strong> or classpath.</li>
                                    </ul>
                                </li>
                                <li>Click <strong>Apply</strong> and <strong>OK</strong>.</li>
                            </ol>

                            <h3>2.2 Run in Debug Mode</h3>
                            <p>There are two main ways to start debugging:</p>
                            <ul>
                                <li>
                                    Use the <strong>bug icon</strong> next to the run configuration (top-right).
                                    This starts your program in debug mode.
                                </li>
                                <li>
                                    Right-click a file (like your main class) in the Project view and choose
                                    <strong>Debug '&lt;ClassName&gt;'</strong>.
                                </li>
                            </ul>

                            <p>
                                When your program hits a breakpoint, IntelliJ will open the <strong>Debug tool
                                    window</strong> at the bottom,
                                and execution will pause.
                            </p>
                        </section>

                        <!-- Breakpoints -->
                        <section id="breakpoints">
                            <h2>3. Breakpoints</h2>
                            <p>
                                Breakpoints are the primary tool for debugging: they tell the debugger where to pause so
                                you can inspect what is happening.
                            </p>

                            <h3>3.1 Adding &amp; Removing Breakpoints</h3>
                            <ol>
                                <li>Open the file you want to debug.</li>
                                <li>Click in the <strong>left gutter</strong> (the gray area to the left of the line
                                    numbers) beside a line of code.</li>
                                <li>A red dot appears: this is your breakpoint.</li>
                                <li>Click the red dot again to remove the breakpoint.</li>
                            </ol>

                            <h3>3.2 Enabling / Disabling Breakpoints</h3>
                            <ul>
                                <li>Right-click the breakpoint and uncheck <strong>Enabled</strong> to temporarily
                                    disable it.</li>
                                <li>Disabled breakpoints turn into a hollow icon but are kept for later use.</li>
                            </ul>

                            <h3>3.3 Viewing All Breakpoints</h3>
                            <p>
                                Press <strong>Ctrl+Shift+F8</strong> (or use the menu <strong>Run &gt; View
                                    Breakpoints...</strong>)
                                to see and manage all breakpoints in your project.
                            </p>
                        </section>

                        <!-- Debug Controls -->
                        <section id="debug-controls">
                            <h2>4. Debug Controls (Step Over, Step Into, Step Out)</h2>
                            <p>
                                When your program pauses at a breakpoint, you control the flow using the toolbar in the
                                Debug window.
                                The icons and names may vary slightly, but the main actions are:
                            </p>

                            <ul>
                                <li><strong>Resume Program</strong> ‚Äì continue running until the next breakpoint or
                                    program end.</li>
                                <li><strong>Step Over</strong> ‚Äì execute the current line, but do not go inside methods;
                                    move to the next line in the same method.</li>
                                <li><strong>Step Into</strong> ‚Äì if the current line calls a method, jump inside that
                                    method and pause at its first line.</li>
                                <li><strong>Step Out</strong> ‚Äì finish the current method and return to the caller.</li>
                                <li><strong>Stop</strong> ‚Äì end the debugging session.</li>
                            </ul>

                            <h3>4.1 When to Use Each</h3>
                            <ul>
                                <li>
                                    Use <strong>Step Over</strong> when you trust a method and just want to see its
                                    effect, not its internal details.
                                </li>
                                <li>
                                    Use <strong>Step Into</strong> when you suspect the bug is inside the method being
                                    called.
                                </li>
                                <li>
                                    Use <strong>Step Out</strong> when you realize you went too deep and want to go back
                                    to the higher-level code.
                                </li>
                            </ul>
                        </section>

                        <!-- Inspecting State -->
                        <section id="inspecting-state">
                            <h2>5. Inspecting Variables &amp; Expressions</h2>
                            <p>
                                The main power of debugging is seeing the state of your program while it runs.
                                IntelliJ gives you several ways to inspect data when execution is paused.
                            </p>

                            <h3>5.1 Variables View</h3>
                            <ul>
                                <li>
                                    In the Debug tool window, there is a <strong>Variables</strong> (or similar) pane
                                    that shows all local variables.
                                </li>
                                <li>
                                    Expand objects (using the small triangle) to see their fields.
                                </li>
                                <li>
                                    Collections and arrays can be expanded to see their elements.
                                </li>
                            </ul>

                            <h3>5.2 Hover Inspection</h3>
                            <p>
                                Move your mouse over a variable in the editor while in debug mode.
                                IntelliJ displays a pop-up with the current value of that variable.
                            </p>

                            <h3>5.3 Watches</h3>
                            <p>
                                Use <strong>Watches</strong> when you want to track specific expressions or variables:
                            </p>
                            <ol>
                                <li>Open the <strong>Watches</strong> tab/panel in the Debug window.</li>
                                <li>Click the <strong>+</strong> icon to add a new watch.</li>
                                <li>Type an expression (e.g., <code>myList.size()</code> or
                                    <code>user.getName()</code>).
                                </li>
                                <li>Now IntelliJ will always show the current value whenever execution is paused.</li>
                            </ol>

                            <h3>5.4 Evaluate Expression</h3>
                            <p>
                                <strong>Evaluate Expression</strong> lets you execute code while paused to test logic or
                                inspect state:
                            </p>
                            <ol>
                                <li>When paused at a breakpoint, click the <strong>Evaluate Expression</strong> button
                                    in the Debug window (often a calculator icon).</li>
                                <li>Type any valid expression that can be compiled in the current context.</li>
                                <li>Press <strong>Evaluate</strong> to view the result.</li>
                            </ol>
                            <p>
                                This is very useful for quickly checking conditions, method results, or exploring new
                                code without changing your source files.
                            </p>
                        </section>

                        <!-- Conditional & Log Breakpoints -->
                        <section id="conditional-log-breakpoints">
                            <h2>6. Conditional &amp; Log Breakpoints</h2>
                            <p>
                                Sometimes you only want to pause or log output when a certain condition is met.
                                IntelliJ supports <strong>conditional breakpoints</strong> and <strong>log
                                    breakpoints</strong>.
                            </p>

                            <h3>6.1 Conditional Breakpoints</h3>
                            <ol>
                                <li>Right-click an existing breakpoint (red dot in the gutter).</li>
                                <li>In the popup, find the <strong>Condition</strong> field.</li>
                                <li>Enter an expression that returns a boolean (e.g., <code>i == 10</code> or
                                    <code>user == null</code>).
                                </li>
                                <li>Now the program will only pause at this breakpoint when the condition is
                                    <strong>true</strong>.
                                </li>
                            </ol>

                            <h3>6.2 Log Breakpoints (Without Stopping)</h3>
                            <ol>
                                <li>Right-click a breakpoint.</li>
                                <li>Check options like <strong>Log message to console</strong> or <strong>Evaluate and
                                        log</strong>.</li>
                                <li>Uncheck <strong>Suspend</strong> if you do not want the program to pause.</li>
                                <li>
                                    Your program will continue to run, but IntelliJ will print debug messages to the
                                    console,
                                    which is useful for tracing execution without stopping.
                                </li>
                            </ol>
                        </section>

                        <!-- Debugging Exceptions -->
                        <section id="debugging-exceptions">
                            <h2>7. Debugging Exceptions</h2>
                            <p>
                                Exceptions often indicate bugs or unexpected situations. IntelliJ can help you
                                understand where and why an exception occurred.
                            </p>

                            <h3>7.1 When an Exception Occurs</h3>
                            <ul>
                                <li>If an uncaught exception is thrown, the debugger will pause at the line where it
                                    happened (if you are in debug mode).</li>
                                <li>The <strong>Frames</strong> or <strong>Call Stack</strong> tab will show you the
                                    chain of method calls that led to the error.</li>
                                <li>The <strong>Variables</strong> tab will show you the values of variables at the
                                    moment of failure.</li>
                            </ul>

                            <h3>7.2 Exception Breakpoints</h3>
                            <ol>
                                <li>Open the <strong>View Breakpoints...</strong> dialog (e.g.,
                                    <strong>Ctrl+Shift+F8</strong>).
                                </li>
                                <li>Click the <strong>+</strong> icon and choose <strong>Java Exception
                                        Breakpoint</strong> (or similar, depending on language).</li>
                                <li>Select an exception class (e.g., <code>NullPointerException</code>,
                                    <code>IOException</code>).
                                </li>
                                <li>
                                    IntelliJ will now pause whenever that exception is thrown, even if it is later
                                    caught,
                                    so you can see exactly where it originates.
                                </li>
                            </ol>
                        </section>

                        <!-- Example Debugging Workflow -->
                        <section id="example-workflow">
                            <h2>8. Example Debugging Workflow</h2>
                            <p>Here is a simple example using Java, but the general idea is similar for other languages.
                            </p>

                            <h3>8.1 Sample Code</h3>
                            <pre><code>public class DebugExample {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3};
        int index = 0;

        while (index &lt;= numbers.length) { // bug: should be &lt; instead of &lt;=
            int value = numbers[index];
            System.out.println("Value: " + value);
            index++;
        }
    }
}</code></pre>

                            <h3>8.2 Steps to Debug in IntelliJ IDEA</h3>
                            <ol>
                                <li>Set a breakpoint on the line <code>int value = numbers[index];</code>.</li>
                                <li>Start the program in <strong>Debug</strong> mode.</li>
                                <li>When execution pauses at the breakpoint:
                                    <ul>
                                        <li>Check <strong>index</strong> and <strong>numbers.length</strong> in the
                                            Variables window.</li>
                                        <li>Use <strong>Step Over</strong> to go through the loop iterations.</li>
                                        <li>Watch how <strong>index</strong> changes on each iteration.</li>
                                    </ul>
                                </li>
                                <li>
                                    When <strong>index</strong> becomes equal to <strong>numbers.length</strong>, the
                                    next iteration will cause an
                                    <code>ArrayIndexOutOfBoundsException</code>. You will see the exception and the
                                    incorrect condition:
                                    <code>index &lt;= numbers.length</code>.
                                </li>
                                <li>Fix the bug by changing the condition to <code>index &lt; numbers.length</code>.
                                </li>
                                <li>Run the program again to confirm it works correctly.</li>
                            </ol>
                        </section>

                        <!-- Tips & Common Mistakes -->
                        <section id="tips-mistakes">
                            <h2>9. Tips &amp; Common Mistakes in Debugging</h2>

                            <h3>9.1 Tips</h3>
                            <ul>
                                <li>Start by reproducing the bug reliably (same inputs, same steps).</li>
                                <li>Use breakpoints near where you suspect the problem is, not random places.</li>
                                <li>Inspect actual values instead of guessing what they might be.</li>
                                <li>Use <strong>Evaluate Expression</strong> to test hypotheses without editing code.
                                </li>
                                <li>
                                    Use <strong>log breakpoints</strong> instead of adding and removing many temporary
                                    <code>System.out.println()</code> or <code>console.log()</code> statements.
                                </li>
                            </ul>

                            <h3>9.2 Common Mistakes</h3>
                            <ul>
                                <li>Forgetting to run in <strong>Debug</strong> mode (using Run instead of Debug).</li>
                                <li>Placing breakpoints in code that never actually runs.</li>
                                <li>Changing code but not rebuilding / rerunning before testing again.</li>
                                <li>Ignoring the call stack, which often clearly shows where things went wrong.</li>
                                <li>Assuming a variable has one value without checking it in the debugger.</li>
                            </ul>

                            <p>
                                With practice, using IntelliJ IDEA's debugger will become a normal part of your
                                development
                                process, helping you understand your code more deeply and find bugs much faster.
                            </p>
                        </section>
                        <hr>
                        <p>
                            Summary: Debugging with IntelliJ IDEA is about using breakpoints, stepping through code,
                            inspecting variables, and understanding exceptions.
                            Mastering these basics will make you much more efficient at tracking down and fixing
                            bugs.
                        </p>

                    </section>
                    <!--//Debugging Section-->


                    <!--//section-->
                </article>
            </div>
        </div>


    </div>





    <!-- Javascript -->
    <script src="../assets/plugins/popper.min.js"></script>
    <script src="../assets/plugins/bootstrap/js/bootstrap.min.js"></script>

    <!-- Page Specific JS -->
    <script src="../assets/plugins/smoothscroll.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
    <script src="../assets/js/highlight-custom.js"></script>
    <script src="../assets/plugins/simplelightbox/simple-lightbox.min.js"></script>
    <script src="../assets/plugins/gumshoe/gumshoe.polyfills.min.js"></script>
    <script src="../assets/js/docs.js"></script>

</body>

</html>